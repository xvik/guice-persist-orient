{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to guice-persist-orient","text":"<p>Guice integration for OrientDB.</p> <p>Release notes - Support - License</p>"},{"location":"#main-features","title":"Main features","text":"<ul> <li>Integration through guice-persist (UnitOfWork, PersistService, @Transactional)</li> <li>Support for document, object and graph databases</li> <li>Database types support according to classpath (object and graph db support activated by adding jars to classpath)</li> <li>All three database types may be used in single transaction (changes will be visible between different apis)</li> <li>Hooks for schema migration and data initialization extensions</li> <li>Extension for orient object to scheme mapper with plugins support</li> <li>Auto mapping entities in package to db scheme or using classpath scanning to map annotated entities</li> <li>Auto db creation (for memory, local and plocal)</li> <li>Different db users may be used (for example, for schema initialization or to use orient security model), including support for user change inside transaction</li> <li>Support method retry on ONeedRetryException</li> <li>Spring-data like repositories with advanced features (e.g. generics usage in query). Great abilities for creating reusable parts (mixins). Support plugins.</li> <li>Basic crud mixins with ability to use object api for graphs</li> <li>Compatible with Play framework</li> </ul> <p>Note</p> <p>Orient team tries to move focus from object api (jpa-like) into document and graph apis.  Library allows you to use pure document and graph apis, but also provides advanced tools to mix object and graph apis. So you can keep model as pojos and connect them with type safe (also pojo) edges.</p>"},{"location":"#documentation-structure","title":"Documentation structure","text":"<p>Library consists of 3 parts:</p> <ul> <li>Core orient integration (user guide section) </li> <li>Object schema mapper (mapping section) - used for schema creation from pojos during startup</li> <li>Repositories framework (repository section) - spring-data like approach of query definitions with annotations </li> </ul> <p>Start reading from getting started guide for introduction.</p> <p>All core apis are described on API page.</p>"},{"location":"api/","title":"Api reference","text":"<p>Page describes core api classes. It does not cover object mapping or  repositories.</p> <p>Core api classes are:</p> <ul> <li><code>TransactionManager</code> transaction (unit of work) manager </li> <li><code>Provider&lt;connection type&gt;</code> provides thread bound connection object inside unit of work</li> <li><code>TxTemplate&lt;connection type&gt;</code> transactional template simplifies transaction handling (used internally by <code>@Transactional</code> annotation)</li> <li><code>SpecificTxTemplate&lt;connection type&gt;</code> special version of tx template with connection object passing to callback</li> <li><code>UserManager</code> allows changing user outside or inside transaction</li> <li><code>DatabaseManager</code> is responsible for lifecycle and pools initialization, may be useful only for loaded types check</li> </ul> <p><code>PersistentContext</code> combines all most used apis for simplified usage (no need to remember everything, just one class). It's not used internally and exist just for public usage. Could be replaced (or extended).</p> <p>Core annotations:</p> <ul> <li>@Transactional - defines transaction scope</li> <li>@TxType - used with transaction annotation to specify transaction type</li> <li>@Retry - catches and retries methods failed with orient ONeedRetryExcepion</li> </ul>"},{"location":"api/#transaction-manager","title":"Transaction manager","text":"<p>Unit of work manager. Used to start/stop/rollback transaction. Used internally by all other tx api.</p> <p>In most cases, it shouldn't be used directly for transaction definition to avoid try-catch code and avoid possibility of not closing transaction. Use TxTemplate or SpecificTxTemplate for manual transaction execution.</p> <p>The most useful method is current transaction check:</p> <pre><code>transactionManager.isTransactionActive()\n</code></pre> <p>Default transaction manager implementation may be substituted in guice module:</p> <pre><code>bind(TransactionalManager.class).to(MyTransactionalManager.class)\n</code></pre> <p>When <code>@Transactional</code> annotation used, transaction type may be defined with <code>@TxType</code> annotation (but in most cases it is not required).</p>"},{"location":"api/#connection-provider","title":"Connection provider","text":"<p>Connection could be acquired only inside transaction (unit of work).</p> <p>Possible connection objects:</p> <ul> <li><code>Provider&lt;ODatabaseObject&gt;</code> for object database connection</li> <li><code>Provider&lt;ODatabaseDocument&gt;</code> for document database connection</li> <li><code>Provider&lt;OrientBaseGraph&gt;</code> for graph database connection (transactional or not)</li> <li><code>Provider&lt;OrientGraph&gt;</code> for transactional graph database connection (will fail if notx transaction type)</li> <li><code>Provider&lt;OrientGraphNoTx&gt;</code> for non transactional graph database connection (will provide only for notx transaction type, otherwise fail)</li> </ul> <p>Note</p> <p>You can't use both <code>OrientGraph</code> and <code>OrientGraphNoTx</code> in the same transaction (type must be used according to transaction type). <code>OrientBaseGraph</code> may be used in places where both types are possible (it's the base class for both).</p> <p>Connection provider logic is implemented in pools (<code>PoolManager</code>). Pool is registered for each connection type (document, object, graph).</p> <p>Important</p> <p>Connection instance is thread bound, so you may be sure that every time <code>provider.get()</code> returns same connection object instance (within transaction).</p>"},{"location":"api/#transaction-templates","title":"Transaction templates","text":"<p>Transaction template abstract work with transaction manager (begin/commit/rollback staff).</p> <p><code>TxTemplate</code> is the core transaction abstraction, used by all other api (<code>@Transactional</code> annotation, <code>SpecificTxTemplate</code>).</p> <p>Sample usage:</p> <pre><code>@Inject TxTemplate&lt;ODatabaseObject&gt; template;\n\n...\ntemplate.doInTransaction(new TxAction&lt;Void&gt;() {\n        @Override\n        public Void execute() throws Throwable {\n            // something\n            return null;\n        }\n    });\n</code></pre> <p>Custom transaction config:</p> <pre><code>template.doInTransaction(new TxConfig(OTransaction.TXTYPE.NOTX), new TxAction&lt;Void&gt;() {\n        @Override\n        public Void execute() throws Throwable {\n            // something\n            return null;\n        }\n    });\n</code></pre> <p>If template is used inside transaction, it's config is ignored.</p> <p><code>SpecificTxTemplate</code> is <code>TxTemplate</code> but with connection object in callback (to avoid calling connection provider inside callback).</p> <p>For example:</p> <pre><code>@Inject SpecificTxTemplate&lt;ODatabaseObject&gt; specificTxTemplate;\n...\nspecificTxTemplate.doInTransaction(new SpecificTxAction&lt;Object, ODatabaseObject&gt;() {\n        @Override\n        public Object execute(ODatabaseObject db) throws Throwable {\n            // something\n            return null;\n        }\n    })\n</code></pre> <p>It also may be called with custom transaction config.</p> <p><code>TxConfig</code> may also configure exception types which will not prevent commit or which should trigger rollback (see guice-persist <code>@Transactional</code> annotation javadoc for more details).</p>"},{"location":"api/#user-manager","title":"User manager","text":"<p><code>UserManager</code> allows you to change connection user. Change may be performed outside of transaction (to affect multiple transactions) or inside transaction (e.g. to check orient security).</p> <p>To change user for multiple transactions:</p> <pre><code>userManager.executeWithUser('user', 'password', new SpecificUserAction&lt;Void&gt;() {\n    @Override\n    public Void execute() throws Throwable {\n        // do work\n    }\n})\n</code></pre> <p><code>SpecificUserAction</code> defines scope of user overriding. This will not implicitly start transaction, but simply binds different user to current thread.</p> <p>Overriding may be used in scheme initialization to use more powerful user or to use orient security model (in this case overriding may be done, for example in servlet filter).</p> <p>Nested user override is not allowed (to avoid confusion). But you can use user overriding inside transaction.</p>"},{"location":"api/#transaction-user","title":"Transaction user","text":"<p>To change user inside transaction:</p> <pre><code>userManager.executeWithTxUser('user', new SpecificUserAction&lt;Void&gt;() {\n    @Override\n    public Void execute() throws Throwable {\n        // do work\n    }\n})\n</code></pre> <p>Must be called inside transaction. Changes user inside current connection using <code>ODatabase.setUser(user)</code> api. This change will affect security checks (probably the most common use case). Nested user override is not allowed (for simplicity).</p> <p>Note</p> <p><code>PersistentContext</code> provides shortcut only for changing user inside transaction.</p>"},{"location":"api/#database-manager","title":"Database manager","text":"<p>Database manager is responsible for lifecycle (start/stop) and pools management.</p> <p>The only useful methods:</p> <pre><code>@Inject DatabaseManager dbManager;\n...\n// check if database type supported\ndbManager.isTypeSupported(DbType.OBJECT)\n// all supported types\ndbManager.getSupportedTypes()\n</code></pre> <p>Database types support is driven by classpath (e.g. if orient-graph dependency is not available, no graph db support will be in runtime).</p> <p>Also, provides access for <code>OrientDB</code> object (new orient api) used internally:</p> <pre><code>OrientDB orient = dbManager.get()\n</code></pre> <p>The same object could be simply injected with</p> <pre><code>@Inject Provider&lt;OrientDB&gt;\n</code></pre> <p>Object might be used for opening direct orient connections (not managed by guice). Quite rare case.</p>"},{"location":"api/#database-credentials","title":"Database credentials","text":"<p>You can get used database credentials through <code>OrientDBFactory</code> object:</p> <pre><code>@Inject OrientDBFactory info;\n...\n\nString dbName = info.getDbName();\n</code></pre> <p>This might be useful in tests to drop context database like:</p> <pre><code>void cleanup() {\n    persistService.stop();\n    // create new connection object after main connection shut down\n    OrientDB db = info.createOrientDB()\n    if (db.exists(info.getDbName())) {\n        db.drop(info.getDbName())\n    }\n    db.close()\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Maven:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;ru.vyarus&lt;/groupId&gt;\n    &lt;artifactId&gt;guice-persist-orient&lt;/artifactId&gt;\n    &lt;version&gt;5.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--\n&lt;dependency&gt;\n    &lt;groupId&gt;com.orientechnologies&lt;/groupId&gt;\n    &lt;artifactId&gt;orientdb-object&lt;/artifactId&gt;\n    &lt;version&gt;3.2.46&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.orientechnologies&lt;/groupId&gt;\n    &lt;artifactId&gt;orientdb-graphdb&lt;/artifactId&gt;\n    &lt;version&gt;3.2.46&lt;/version&gt;\n&lt;/dependency&gt;--&gt;\n</code></pre> <p>Gradle:</p> <pre><code>implementation 'ru.vyarus:guice-persist-orient:5.0.0'\n//implementation \"com.orientechnologies:orientdb-object:3.2.46\"\n//implementation \"com.orientechnologies:orientdb-graphdb:3.2.46\"\n</code></pre> <p>Tip</p> <p>Add object and graph dependencies if support required.</p> <p>Important</p> <p>It's very important for object db to use exact <code>javassist</code> version it depends on. If other libraries in  your classpath use <code>javassist</code>, check that newer or older version not appear in classpath.</p>"},{"location":"getting-started/#usage","title":"Usage","text":""},{"location":"getting-started/#install-guice-module","title":"Install guice module","text":"<pre><code>install(new OrientModule(url, user, password));\n</code></pre> <p>See orient documentation for supported db types. In short:</p> <ul> <li><code>memory:dbname</code> to use in-memory database</li> <li><code>embedded:dbname</code> or <code>plocal:</code> to use embedded database (no server required, local fs folder will be used); db name must be local fs path</li> <li><code>remote:dbname</code> to use remote db (you need to start server to use it)</li> </ul> <p>By default, use <code>admin/admin</code> user.</p> <p>Note</p> <p>Auto database creation for local types is enabled by default, but you  can switch it off.  </p> <p>Remote db creation might be enabled manually with `OrientModule#autoCreateRemoteDatabase(user, pass, type)</p> <p>To change default orient configuration use:</p> <pre><code>install(new OrientModule(url, user, password).withConfig(config));\n</code></pre> <p>Where <code>config</code> is <code>OrientDBConfig</code>. By default, <code>OrientDBConfig.defaultConfig()</code> is used.</p>"},{"location":"getting-started/#lifecycle","title":"Lifecycle","text":"<p>You need to manually start/stop persist service in your code (because only you can control application lifecycle). On start connection pools will be initialized, database created (if required) and scheme/data initializers called. Stop will shutdown all connection pools.</p> <pre><code>@Singleton\npublic class MyLifecycle {\n\n    @Inject\n    private PersistService orientService;\n\n    public void start(){\n        orientService.start();\n    }\n\n    public void stop(){\n        orientService.stop();\n    }\n}\n</code></pre> <p>Assuming start and stop methods are called on application startup/shutdown. </p>"},{"location":"getting-started/#connections","title":"Connections","text":"<p>Document (actually multi-model)  is the core connection type. Object and graph  apis use document connection internally. Connection object mainly defines the result of queries: </p> <ul> <li>document connection will always return ODocument</li> <li>object connection returns mapped pojos (actually proxies) or ODocument for fields selections and</li> <li>graph api returns Vertex and Edge types.</li> </ul> <p>And of course connections provide specific apis for types.</p> <p>You can use any connections within single transaction and changes made in one connection type will be visible in other connections. This allows you, for example to update data using object api and create relations using graph api.</p> <p>To access connection object inside transaction use <code>PersistentContext</code> generified with the type of required connection.</p> <ul> <li><code>PersistentContext&lt;ODatabaseObject&gt;</code> for object database connection</li> <li><code>PersistentContext&lt;ODatabaseDocument&gt;</code> for document database connection</li> <li><code>PersistentContext&lt;OrientBaseGraph&gt;</code> for graph database connection (transactional or not)</li> <li><code>PersistentContext&lt;OrientGraph&gt;</code> for transactional graph database connection (will fail if notx transaction type)</li> <li><code>PersistentContext&lt;OrientGraphNoTx&gt;</code> for non transactional graph database connection (will provide only for notx transaction type, otherwise fail)</li> </ul> <p>Note</p> <p>you can't use both OrientGraph and OrientGraphNoTx in the same transaction (type must be used according to transaction type). OrientBaseGraph may be used in places where both types are possible (its the base class for both).</p> <p>Note</p> <p><code>PersistentContext</code> methods are shortcuts for low level api (simplifies usage). You can extend it to add more shortcut methods or make your own: it is not used internally and exists only for public usage.</p> <p>For example</p> <pre><code>public class MyService {\n\n    @Inject    \n    private PersistenceContext&lt;ODatabaseObject&gt; context;\n\n    public List&lt;Model&gt; findByName(final String name) {\n        // manual transaction declaration\n        return context.doInTransaction((db) -&gt; \n            // pure orient api\n            db.query(new OSQLSynchQuery&lt;Model&gt;(\"select from Model where name=?\"), name)\n        );\n    }\n}\n</code></pre> <p>Alternatively, you can directly inject connections:</p> <pre><code>@Inject\nprivate Provider&lt;ODatabaseObject&gt; db;\n</code></pre> <p>But note that it would not work without external transaction.</p>"},{"location":"getting-started/#transactions","title":"Transactions","text":"<p>There are 3 ways to declare transaction:</p> <ul> <li><code>@Transactional</code> annotation on guice bean or single method (additional <code>@TxType</code> annotation allows to define different transaction type for specific unit of work)</li> <li>Inject <code>PersistentContext</code> bean into your service and use its methods</li> <li>Using <code>TransactionManager</code> begin() and end() methods (low level trasaction control).</li> </ul> <p>First two options are better, because they automatically manage rollbacks and avoid not closed (forgot to call end) transactions.</p> <p>For example, to declare transaction using annotation:</p> <pre><code>@Transactional\npublic class MyService {\n    public void doSomething() {...}\n}\n</code></pre> <p>Or</p> <pre><code>public class MyService {\n    @Transactional\n    public void doSomething() {...}\n}\n</code></pre> <p>Warning</p> <p>Private methods can't be annotated with <code>@Transactional</code>: method must be at least package-private.</p> <p>Transaction scopes could intersect: e.g. if transactional method calls bean, also annotated as transactional, then only root transaction scope will work (no sub-transaction or anything like this).  </p> <p>Tip</p> <p>If you need to execute without transaction, you still need to declare it <pre><code>@Transactional\n@TxType(OTransaction.TXTYPE.NOTX)\npublic void method()\n</code></pre> This is required, for example, for schema updates</p> <p>Note</p> <p>in contrast to spring default proxies, in guice when you call bean method inside the same bean, annotation interceptor will still work. So it's possible to define few units of work withing single bean using annotations:</p> <pre><code>public void nonTxMethod(){\n    doTx1();\n    doTx2();\n}\n\n@Transactional\nvoid doTx1() {..}\n\n@Transactional\nvoid doTx2() {..}\n</code></pre> <p>Warning</p> <p>When you get error like   <pre><code>Database instance is not set in current thread. Assure to set it with: ODatabaseRecordThreadLocal.instance().set(db)\n</code></pre> It almost certainly means that you perform transactional operation outside of transaction. Simply enlarge transaction scope.    </p> <p>When you inside transaction, <code>activateOnCurrentThread()</code> is called each time you obtain connection from raw connection provider or PersistentContext and you will always have correctly bound connection.    </p> <p>For example, even document creation (<code>new ODocument()</code>) must be performed inside transaction.</p>"},{"location":"getting-started/#schema-initialization","title":"Schema initialization","text":"<p>In order to work with database, you obviously need to initialize it's schema first.</p> <pre><code>public class MySchemeInitializer implements SchemeInitializer {\n\n    @Inject\n    private Provider&lt;ODatabaseObject&gt; provider;\n\n    public void initialize() {\n        final  ODatabaseObject db = provider.get();\n        if (db.getMetadata().getSchema().existsClass(\"Account\")) {\n            // schema already created - do nothing\n            return;            \n        }\n\n        OClass account = db.getMetadata().getSchema().createClass(\"Account\");\n        account.createProperty(\"id\", OType.Integer);\n        account.createProperty(\"birthDate\", OType.Date);\n\n        //or using sql statements\n        db.command(new OCommandSQL(\"CREATE CLASS Account\")).execute();         \n    }\n}\n</code></pre> <p>To do it register implementation of <code>ru.vyarus.guice.persist.orient.db.scheme.SchemeInitializer</code>  in guice module:</p> <pre><code>bind(SchemeInitializer.class).to(MySchemeInitializer.class);\n</code></pre> <p>Initializer is called without transaction (NOTX transaction type) as orient requires database updates to be performed without transaction.</p>"},{"location":"getting-started/#object-scheme-mapping","title":"Object scheme mapping","text":"<p>If you are using object api, then you can create schema directly from your model objects. In this case you dont need to implement your own <code>SchemeInitializer</code>, instead register module:</p> <pre><code>install(new AutoScanSchemeModule(\"my.model.root.package\"));\n</code></pre> <p>Module will find all classes, annotated with <code>@Persistent</code> using classpath scan and register them in orient.</p> <p>For example:</p> <pre><code>@Persistent\npublic class Account {\n        @Id\n        private String id;\n        @Version\n        private Long version;\n        private String myProp;\n\n        // getters and setters        \n}\n</code></pre> <p>Tip</p> <p>If you want to use graph api with objects then annotate your class as <code>@VertexType</code> or <code>@EdgeType</code> in order to correct create graph schema from object.</p> <p>More about object scheme mapping.</p>"},{"location":"getting-started/#data-initialization","title":"Data initialization","text":"<p>You may need to initialize some sample data before start (e.g.for testing) or perform some data updates. Implement <code>ru.vyarus.guice.persist.orient.db.data.DataInitializer</code>:</p> <pre><code>public class MyDataInitializer implements DataInitializer {\n    @Inject\n    private Provider&lt;ODatabaseObject&gt; provider;\n\n    @Override\n    @Transactional\n    void initializeData() {\n        final  ODatabaseObject db = provider.get();\n        // init only if database is empty\n        if (db.getMetadata().getSchema().getClass(Account.class).count() == 0) {\n            db.save(new Account(\"something 1\"));\n            db.save(new Account(\"something 2\"));\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#repositories","title":"Repositories","text":"<p>You can also use interfaces for queries declaration (very like spring-data).</p> <p>Register repositories module:</p> <pre><code>install(new RepositoryModule());\n</code></pre> <p>Now you can declare:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface AccountRepository {\n\n    @Query(\"select from Account\")\n    List&lt;Account&gt; selectAll(); \n\n    @Query(\"update Account set name = ? where name = ?\")\n    int updateName(String newName, String oldName);\n\n    @Query(\"insert into Account (name) values(:name)\")\n    Account create(@Param(\"name\") String name);\n}\n</code></pre> <p>Later this repository could be injected as normal guice bean:</p> <pre><code>@Transactonal\npublic class MyService {\n    @Inject\n    private AccountRepository repo;\n\n    public void doSomething() {\n        List&lt;Account&gt; all = repo.selectAll();\n    }\n}\n</code></pre> <p>Or you can use repository methods directly in other beans:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic abstract class MyDao {\n\n    @Query(\"select from Account\")\n    public abstract List&lt;Account&gt; selectAll();\n\n    // normal method\n    public void doSomething() {\n        List&lt;Account&gt; all = selectAll();\n        ...\n    }\n}\n</code></pre> <p>Tip</p> <p>IDE could warn you about <code>@ProvidedBy(DynamicSingletonProvider.class)</code>, but it's the only way to avoid additional (direct) registrations. If warning is annoying for you, you can register beans manually instead: <pre><code>bind(AccountRepository.class).to(DynamicClassGenerator.generate(MyInterfaceRepository.class)).in(Singleton.class)\n</code></pre></p> <p>Note</p> <p>Guice aop will work on repositories (in fact it's implemented using aop), so you may use any other aop-driven annotations there.    </p> <p>More about repositories </p>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>If you want to use orient with object mappings, then guice initialization will look like:</p> <pre><code>public class MyModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        install(new OrientModule(\"memory:test\", \"admin\", \"admin\"));\n        install(new AutoScanSchemeModule(\"my.model.root.package\"));\n        install(new RepositoryModule());\n    }\n}\n</code></pre> <p>And you will need to start and shutdown persistence support:</p> <pre><code>@Inject\nprivate PersistService orientService;\n\n// called manually\norientService.start();\n\n...\n\n// called manually before shutdown\norientService.stop();\n</code></pre>"},{"location":"about/compatibility/","title":"OrientDB compatibility","text":"OrientDB Guice guice-persist-orient 3.2 7.0.0 5.0.0 3.1 5.0.1 4.1.0 3.0 5.0.1 4.0.0 2.2 4.2.0 3.3.2 2.1 4.1.0 3.2.0 2.0 4.0.0 3.1.1 1.0 4.0.0 2.1.0"},{"location":"about/history/","title":"Release notes","text":""},{"location":"about/history/#500-2025-11-18","title":"5.0.0 (2025-11-18)","text":"<ul> <li>(BREAKING) Update to guice 7.0.0 (jakarta namespace)</li> <li>(BREAKING) Upgrade to OrientDB 3.2.x (what's new)</li> </ul>"},{"location":"about/history/#410-2021-07-05","title":"4.1.0 (2021-07-05)","text":"<ul> <li>Orient 3.1 compatibility (updated to 3.1.12)</li> </ul>"},{"location":"about/history/#400-2021-07-04","title":"4.0.0 (2021-07-04)","text":"<ul> <li>Update to guice 5.0.1</li> <li>(breaking) Update to Orient 3.0.38<ul> <li>Dropped java 1.6 support</li> <li>Bound connection objects changed:<ul> <li>Provider -&gt; Provider <li>Provider -&gt; Provider <li>With new orient api (unified document and graph api), graph pools remains for legacy thinkerpop 2 only</li> <li>orientdb-object and orientdb-graph dependencies become optional (no more exclusions, directly specify required libs instead)</li> <li>OrientModule:<ul> <li>As before, single uri passed which includes both system path (plocal) and db name   Internally, it splits to create OrientDB object and open db connections with db name (new api)</li> <li>Provider may be injected now to manually open connections (OrientDB object is a new api object used for orient connections (or pools) creation) <li>OrientDBFactory bean may be injected to get access to database configuration (url, user, etc.)   Before this information was bound with guice constants</li> <li>New option autoCreateRemoteDatabase(user, pass, type) is available to automatically create rmote databases (mainly for tests)</li> <li>New option withConfig(conf) allows specifying custom config for OrientDB object (by default, OrientDBConfig.defaultConfig() used)</li> <li>Remote database creation indirect configuration support for tests (instead of direct config in module):   OrientDBFactory.enableAutoCreationRemoteDatabase(user, pass, type)   OrientDBFactory.disableAutoCreationRemoteDatabase()</li> <li>Pools contract changed: PoolManager.start(String) now accepts database name instead of complete url</li> <li>DocumentPool:<ul> <li>Now use new ODatabasePool pool implementation (instead of OPartitionedDatabasePoolFactory)</li> <li>Removed pool recovery logic (since 1.x: when pool failed to provide correct connection it was re-created).   Assuming new pool is more stable.</li> <li>Different user credentials (UserManager.executeWithUser) will create separate connection outside the pool.</li> </ul> </li> <li>Object api now may be used to properly remove graph nodes with edges (because graph consistency is on document level now)</li> <li>Remove useHashIndex attribute in @FullTextIndex schema annotation   (OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX removed in orient 3.0.38:   https://github.com/orientechnologies/orientdb/commit/bfceffa50d3f708f5c1c05dab1f082861df01e12#diff-3371617e7407306ad4397a0835f64175314b828295d5ad88891c051915d2d8aaL226)</li>"},{"location":"about/history/#332-2018-04-02","title":"3.3.2 (2018-04-02)","text":"<ul> <li>Guice 4.2.0 compatibility</li> </ul>"},{"location":"about/history/#331-2018-01-17","title":"3.3.1 (2018-01-17)","text":"<ul> <li>Fix ignoreNullValues flag support for @Index and @CompositeIndex scheme extensions (#16) (breaking) since orient 2.2 ignoreNullValues is false by default, but @Index and @CompositeIndex annotations use ignoreNullValues = true by default and it was not applied properly before. Now flag will apply properly,  which may change existing indexes. One consequence I know is composite index with ignoreNullValues = true is not used for single field searches (don't know why). </li> </ul>"},{"location":"about/history/#330-2017-11-07","title":"3.3.0 (2017-11-07)","text":"<ul> <li>Update to orient 2.2</li> <li>Support custom types installation   with new method: OrientModule#withCustomTypes(OObjectSerializer...) (#14)</li> <li>Support external connection (thread bound) re-use: when transaction started with TxConfig.external() thread bound   connection used instead of new connection. Commits and rollbacks are not applied automatically: supposed that manual    connection is completely managed externally. Useful in case when already existing connection must be (re)used in guice.<ul> <li>(breaking) custom TransactionManager and/or PoolManager implementations must be updated to support external transactions</li> </ul> </li> <li>New service RecordConverter may be used directly to:<ul> <li>convert ODocument to object or vertex </li> <li>apply default repository method converter (e.g. apply projection)</li> </ul> </li> <li>@Listen parameter extension changes:<ul> <li>(breaking) no longer could be used with @Query (because it does not work properly for remote connection and not guaranteed by the documentation) </li> <li>wraps provided listener with an external transaction (thread bound connection (used by orient) could be used in guice)    </li> </ul> </li> <li>AsyncQuery changes:<ul> <li>custom AsyncQueryListener interface can be used instead of OCommandResultListener to apply automatic result conversion    (with RecordConverter to mimic the same behaviour as for usual method result)</li> <li>new <code>blocking</code> attribute to switch execution into non blocking mode (OSQLNonBlockingQuery).    Non blocking methods may return Future to monitor async execution (but not able to cancel!).</li> <li>exception appeared inside async listener is intercepted and logged but not propagated:    only false returned to stop query processing. This is required for proper orient connection handling    (it does not expect exceptions in some modes)          </li> </ul> </li> <li>Add @LiveQuery repository extension (live queries support)<ul> <li>required orient OLiveResultListener parameter must be used with @Listen annotation</li> <li>custom LiveQueryListener interface can be used instead of OLiveResultListener to apply automatic result conversion    (with RecordConverter to mimic the same behaviour as for usual method result).</li> </ul> </li> <li>Support repository result projection on collections (e.g. @Query(\"select name from Model\") List\\ select())."},{"location":"about/history/#320-2016-09-25","title":"3.2.0 (2016-09-25)","text":"<ul> <li>Update to orient 2.1</li> <li>Update to guice 4.1</li> <li>Avoid deprecated OCommandRequest api usage (deprecated in 2.1):  @FetchPlan, @Limit and @Timeout extensions now modifies query instead of using OCommandRequest setters</li> <li>(behavior change) @EdgeType and @VertexType extensions now assign superclass directly to annotated type (or not if hierarchy already contains required type)</li> <li>Call activateOnCurrentThread() in pools for each connection obtain (e.g. context.getConnection()) to guarantee proper db instance bound to thread</li> <li>Fix guice circular proxy (between transaction manager and pools)</li> <li>Fix child injector and private modules support for RepositoryModule (#7)</li> <li>Fix playframework compatibility (#10)</li> </ul>"},{"location":"about/history/#311-2015-08-16","title":"3.1.1 (2015-08-16)","text":"<ul> <li>Improve graph connection recognition on repository methods: recognize all graph types implementing Vertex or Edge (e.g. OrientVertex, OrientEdge)</li> </ul>"},{"location":"about/history/#310-2015-07-04","title":"3.1.0 (2015-07-04)","text":"<ul> <li>Add @RidElVar parameter extension to bind rid directly into query from any source (string, object, document, vertex or collections).</li> <li>Add @CaseInsensitive scheme field extension: sets collate ci for case insensitive fields comparison in queries. Also should be used for creation of ci indexes.</li> <li>Add ignoreNullValues option support for @Index and @CompositeIndex scheme extensions</li> <li>Add @FulltextIndex scheme field extension for fulltext index definitions</li> <li>Add @LuceneIndex and @CompositeLuceneIndex scheme extensions for fulltext lucene index definitions</li> <li>Fix modules usage in child injector</li> <li>Improve connection hint support in repository annotations: now hint is always used in priority, which allows to write more complex result converters</li> <li>Add ObjectVertexCrud mixin to correctly work with vertexes from object api</li> <li>Add EdgesSupport and EdgeTypeSupport mixins to simplify work with edges using object api</li> <li>Fix temporal id problem for detached objects (affects ObjectCrud, ObjectVertexCrud and @DetachResult)</li> <li>ObjectCrud: add getAllAsList, objectToDocument and documentToObject methods</li> </ul>"},{"location":"about/history/#302-2015-05-16","title":"3.0.2 (2015-05-16)","text":"<ul> <li>Orient 2.0.9 compatibility: removed @LockStrategy extension, because lock setter removed from OCommandRequest (use sql LOCK statement instead)</li> </ul>"},{"location":"about/history/#301-2015-05-05","title":"3.0.1 (2015-05-05)","text":"<ul> <li>Fix stale connections in pools</li> <li>Fix sometimes redundant connection in db auto creation check</li> <li>Fix schema extensions for remote connection (more often schema synchronization)</li> </ul>"},{"location":"about/history/#300-2015-03-14","title":"3.0.0 (2015-03-14)","text":"<ul> <li>Orient 2 compatibility</li> <li>DocumentPool use OPartitionedDatabasePool instead of deprecated ODatabaseDocumentPool</li> <li>(breaking) Default pools implementation now rely on document pool only (no more separate transactions for each type). This allows using all connection types in one transaction and all changes will be visible to each type.</li> <li>(breaking) Connection initialization moved from DatabaseManager to pool implementation (graph and object  connections update scheme on first connection). Now each pool did db connection on startup to check connection and  let orient properly update scheme on start.</li> <li>(breaking) TxTemplate and SpecificTxTemplate now propagate only runtime exceptions and wrap checked exceptions  into runtime. This simplifies general usage (most orient exceptions are runtime)</li> <li>ObjectCrudMixin: added multiple detachAll methods (in orient 2 object proxies doesn't work outside of transaction, so detaching is more important)</li> <li>DocumentCrudMixin: added create method to create document inside of transaction (in orient 2 it's now impossible to create document outside of transaction, but document changes doesn't require ongoing transaction)</li> <li>Add PersistentContext class, which combines connection provider, both templates and provide access to TransactionManager. It should be used instead of low level staff (simplifies usage)</li> <li>Remove deprecated finders auto scanning</li> <li>(breaking) Finders rewritten to extensions based architecture. Finder module renamed to repository to follow spring-data style (as well known and very similar realization). Not owned annotations (@Named, @Finder, @FirstResult, @MaxResults) replaced with spring-data like or orient specific annotations (@Param, @Query, @Function, @Skip, @Limit). Many annotations and classes renamed due to module rename.</li> <li>Many new repository features</li> <li>Ability to change user inside transaction (for example for security checks).</li> <li>Retry annotation to catch ONeedRetryException and re-execute method.</li> <li>(breaking) schemeMappingPackage option removed from OrientModule. Shortcut modules now must be used together with OrientModule and not substitute it. Modules renamed to AutoScanSchemeModule and PackageSchemeModule.</li> <li>Model class to scheme mapper, using orient default mapper, but with extensions support (custom annotations). AbstractObjectInitializer now generic enough to use for custom classpath filtering method.</li> </ul>"},{"location":"about/history/#210-2015-01-06","title":"2.1.0 (2015-01-06)","text":"<ul> <li>Finders now managed by guice and any additional aop could be applied. Abstract beans could define finder methods. (integration implemented in external library)</li> <li>Finders auto scan api deprecated: now finder bean could be marked with @ProvidedBy and rely on guice JIT resolution</li> <li>Fix transactional aop warnings on jdk8</li> <li>Fix finder descriptors cache</li> <li>Add ability to disable finder descriptors cache using property and method to clear current cache</li> </ul>"},{"location":"about/history/#202-2014-11-26","title":"2.0.2 (2014-11-26)","text":"<ul> <li>Update orient (1.7.9 &gt; 1.7.10 (changes))</li> <li>Fix single value vertex return from finder (projection should not occur)</li> <li>Add explicit scheme synchronization for AutoScanSchemeInitializer and PackageSchemeInitializer (useful for dynamic environments, like tests)</li> </ul>"},{"location":"about/history/#201-2014-11-19","title":"2.0.1 (2014-11-19)","text":"<ul> <li>Generics resolution extracted to separate lib generics-resolver</li> </ul>"},{"location":"about/history/#200-2014-11-05","title":"2.0.0 (2014-11-05)","text":"<ul> <li>Support different users (for example, to init schema with more powerful user and to use orient security model). Breaks pools api compatibility</li> <li>AutoScanFinderModule accept multiple packages for scanning</li> <li>Add document and vertex projection for single field (works for plain and array result): useful for count (or other aggregation functions) or selecting single field</li> <li>Support inheritance for finder beans and interfaces (mixins) and generics recognition through all hierarchy</li> <li>Support generic type query placeholders (finder class generic used as query placeholder)</li> <li>Add delegate finders (annotated interface method delegates execution to guice bean method)</li> <li>Add crud mixins for object and document finders: DocumentCrudMixin, ObjectCrudMixin</li> <li>Add pagination mixin for object and document finders: PaginationMixin  </li> </ul>"},{"location":"about/history/#111-2014-10-01","title":"1.1.1 (2014-10-01)","text":"<ul> <li>Fix finder behaviour: empty collection conversion to single element</li> </ul>"},{"location":"about/history/#110-2014-09-27","title":"1.1.0 (2014-09-27)","text":"<ul> <li>Fix finder module available db types detection</li> <li>Add query placeholders support for finders</li> <li>Update orient (1.7.8 &gt; 1.7.9) - important hotfix</li> <li>Add Optional support as finder return type (jdk or guava Optional)</li> <li>Add orient module option to disable database auto creation</li> <li>Update guice (4.beta4 -&gt; 4.beta5)</li> </ul>"},{"location":"about/history/#103-2014-09-15","title":"1.0.3 (2014-09-15)","text":"<ul> <li>Fix remote connection support (avoid database creation)</li> </ul>"},{"location":"about/history/#102-2014-08-16","title":"1.0.2 (2014-08-16)","text":"<ul> <li>Fix pmd/checkstyle warnings</li> </ul>"},{"location":"about/history/#101-2014-08-05","title":"1.0.1 (2014-08-05)","text":"<ul> <li>Fix generated pom</li> </ul>"},{"location":"about/history/#100-2014-08-05","title":"1.0.0 (2014-08-05)","text":"<ul> <li>Added dynamic finders (as separate module)</li> <li>Module configuration moved from constructor to chained methods</li> <li>Default object scheme initializers now support graph compatible scheme creation</li> <li>Remove dependency on reflections library </li> <li>Important bugs fixed as a result of better tests coverage</li> </ul>"},{"location":"about/history/#090-2014-07-29","title":"0.9.0 (2014-07-29)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2014-2025, Vyacheslav Rusakov</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/release-notes/","title":"5.0.0 Release Notes","text":"<p>Important</p> <p>The release is completely working, but repositories part was not migrated to the new api and use commands api as before (now deprecated).</p> <p>Manual indexes creation was deprecated (assumed to be completely removed), but  index creation extensions are completely working now.</p> <p>Overall, orientdb is going to drop object database support (most likely in version 4), so all related features will have to be removed. I hope youtrackdb  would be already released at that time providing new object api (and so most object-related features could be ported to a new youtrackdb integration module).</p> <p>Release targets orientdb 3.2 compatibility and guice 7 (jakarta.inject).  No api or behavior changes.</p> <p>Orient 3.2 release notes)</p> <p>If migrating from orinetdb 2.x, see guice-persist-orient 4.0.0 release notes  for orient 3 related updates.</p>"},{"location":"about/release-notes/#known-issues","title":"Known issues","text":"<p>Remains the same from version 4.0.0 (due to not migrated repositories):</p> <ul> <li>Conversion for new OVertex and OEdge objects not supported</li> <li>Streaming api not supported</li> <li>Live queries unsubscription method might not be called on remote connection in some cases (looks like a bug)</li> <li>Functions, executed through object api, might produce incorrect results (with nulls).   Marker exception would be thrown to indicate this case.</li> </ul> <p>Also, there is a known problem that OrientModule is using object db classes and so it's not possible to use it without orientdb-object jar.</p>"},{"location":"about/release-notes/#migration","title":"Migration","text":"<p>Replace <code>javax.inject</code> usages with <code>jakarta.inject</code>.</p>"},{"location":"about/support/","title":"Support","text":"<ul> <li>Gitter - chat</li> <li>Github issues - problems / enhancements</li> </ul>"},{"location":"guide/cache/","title":"Cache","text":"<p>Three caches used:</p> <ul> <li>Scheme object mapping cache</li> <li>Repository descriptors</li> <li>Generics cache</li> </ul>"},{"location":"guide/cache/#scheme-object-mapping-cache","title":"Scheme object mapping cache","text":"<p>When predefined <code>PackageSchemeModule</code> or <code>AutoScanSchemeModule</code> object mapping modules used or <code>ObjectSchemeInitializer</code> used directly, mapped objects are cached.</p> <p>The is required to avoid redundant computations for registering same types: if models use some base class, then base class would be registered multiple times (for each entity) without cache.</p> <p>Normally, cache should not cause problems, because scheme is initialized on application start and doesn't changed anymore.</p> <p>Cache may be cleared at any time:</p> <pre><code>@Inject ObjectSchemeInitializer initializer;\n...\ninitializer.clearModelCache();\n</code></pre>"},{"location":"guide/cache/#repository-descriptors","title":"Repository descriptors","text":"<p>Repository descriptors computed on first repository method execution and cached to speed up future method executions.</p> <p>If you use JRebel or other class reloading tool (maybe some other reason) you will need to disable descriptors caching.</p> <p>To do it set system property or environment variable:</p> <pre><code>ru.vyarus.guice.persist.orient.repository.core.MethodDescriptorFactory.cache=false\n</code></pre> <p>Or from code:</p> <pre><code>MethodDescriptorFactory.disableCache();\n</code></pre> <p>Also you can clear cache manually (on instance):</p> <pre><code>@Inject MethodDescriptorFactory factory;\n...\nfactory.clearCache()\n</code></pre> <p>Note</p> <p>Disabling descriptors case, also disables generics resolution cache.</p>"},{"location":"guide/cache/#generics-cache","title":"Generics cache","text":"<p>External library used for generics resolution: generics-resolver. It maintains resolved class generics cache (to avoid resolution for same classes).</p> <p>Note</p> <p>Disabling descriptors cache will disable generics cache, so usually you don't need to know about it.</p>"},{"location":"guide/configuration/","title":"Configuration","text":"<p>Core orient integration is provided by <code>OrientModule</code>:</p> <pre><code>install(new OrientModule(url, user, password));\n</code></pre> <p>See orient documentation for supported db types. In short:</p> <ul> <li><code>memory:dbname</code> to use in-memory database</li> <li><code>embedded:dbname</code> or <code>plocal:</code> to use embedded database (no server required, local fs folder will be used); db name must be local fs path</li> <li><code>remote:dbname</code> to use remote db (you need to start server to use it)</li> </ul> <p>By default use <code>admin/admin</code> user.</p>"},{"location":"guide/configuration/#auto-database-creation","title":"Auto database creation","text":"<p>Auto database creation for local types (all except 'remote') is enabled by default, but you can switch it off.  Auto creation is nice for playing/developing/testing phase, but most likely will not be useful for production.</p> <pre><code>install(new OrientModule(url, user, password)\n                .autoCreateLocalDatabase(false));\n</code></pre> <p>Remote database creation could be enabled with:</p> <pre><code>install(new OrientModule(url, user, password)\n        .autoCreateRemoteDatabase(serverUser, pass, dbType));\n</code></pre>"},{"location":"guide/configuration/#remote-auto-creation-in-tests","title":"Remote auto creation in tests","text":"<p>There is a special shortcut for enabling remote database creation in tests:</p> <pre><code>OrientDBFactory.enableAutoCreationRemoteDatabase(serverUser, serverPassword, dbType)\n</code></pre> <p>Must be called before persistence service startup. The behaviour is the same as with direct module configuration</p> <p>Static call just sets system properties, used internally for implicit configuration.,</p> <p>To clean up such properties (if required) use:</p> <pre><code>OrientDBFactory.disableAutoCreationRemoteDatabase()\n</code></pre>"},{"location":"guide/configuration/#orient-configuration","title":"Orient configuration","text":"<p>In order to modify new <code>OrientDBConfig</code> values use:</p> <pre><code>OrientDBConfig config = OrientDBConfig.builder()...build()\ninstall(new OrientModule(url, user, password)\n                .withConfig(config));\n</code></pre> <p>By default, config is <code>OrientDBConfig.defaultConfig()</code></p>"},{"location":"guide/configuration/#runtime-configuration-changes","title":"Runtime configuration changes","text":"<p>At runtime configuration could be done changed on instance:</p> <pre><code>@Inject Provider&lt;ODatabaseDocument&gt; db;\n\ndb.get().getStorage().getConfiguration()\n</code></pre> <p>Or globally (even before startup):</p> <pre><code>OGlobalConfiguration.MVRBTREE_NODE_PAGE_SIZE.setValue(2048);\n</code></pre> <p>Read about all configuration options</p>"},{"location":"guide/configuration/#default-transaction-type","title":"Default transaction type","text":"<p>Default transactions configuration may be specified as additional module parameter. By default, OPTIMISTIC transactions used (use optimistic locking based on object version, same way as hibernate optimistic locking).  NOTX mode disables transactions.</p> <p>For example, to switch off transactions use:</p> <pre><code>install(new OrientModule(url, user, password)\n                .defaultTransactionConfig(new TxConfig(OTransaction.TXTYPE.NOTX));\n</code></pre>"},{"location":"guide/configuration/#custom-orient-types","title":"Custom orient types","text":"<p>You may need to use orient custom types (custom converter to/from object, used only in object connection).</p> <p>To register custom type:</p> <pre><code>install(new OrientModule(url, user, password)\n                .withCustomTypes(MyTypeSerializer.class));\n</code></pre> <p>where <code>MyTypeSerializer implements OObjectSerializer</code></p> <p>Serializers are assumed to be guice beans: declare it in guice module if required, otherwise guice JIT will be used to  obtain converter instance.</p> <p>Custom converters are collected using guice multibinder feature, so you can also install custom converter by using multibinder directly:</p> <pre><code>Multibinder.newSetBinder(binder(), OObjectSerializer.class)\n        .addBinding().to(serializerClass);\n</code></pre>"},{"location":"guide/configuration/#scheme-initialization","title":"Scheme initialization","text":"<p>To initialize (or migrate) scheme register implementation of</p> <pre><code>ru.vyarus.guice.persist.orient.db.scheme.SchemeInitializer\n</code></pre> <p>Example:</p> <pre><code>install(new OrientModule(url, user, password));\nbind(SchemeInitializer.class).to(MySchemeInitializer.class);\n</code></pre> <p>Scheme initializer is called in NOTX unit of work (orient requires database scheme updates to be performed without transaction).</p> <p>By default, no-op implementation enabled.</p>"},{"location":"guide/configuration/#object-scheme-mapping","title":"Object scheme mapping","text":"<p>If you use object api you can use provided object scheme mapper to create (or update) database from pojo beans (JPA like).</p> <p>Tip</p> <p>it is also able to mix object mapping with graph types, so you can mix object and graph apis (see @EdgeType and @VertexType). </p> <p>See object scheme mapper guide for details. </p> <p>Note</p> <p>Custom migration annotations could be easily added.</p>"},{"location":"guide/configuration/#data-initialization","title":"Data initialization","text":"<p>To initialize (or migrate) data register implementation of</p> <pre><code>ru.vyarus.guice.persist.orient.db.data.DataInitializer\n</code></pre> <p>By default, no-op implementation enabled.</p> <p>Example:</p> <pre><code>bind(DataInitializer.class).to(YourDataInitializerImpl.class);\n</code></pre> <p>Initializer is called WITHOUT predefined unit of work, because of different possible requirements. You should define unit of work (maybe more than one) yourself (with annotation or manual).</p>"},{"location":"guide/configuration/#lifecycle","title":"Lifecycle","text":"<p>You need to manually start/stop persist service in your code (because only you can control application lifecycle). On start connection pools will be initialized, database created (if required) and scheme/data initializers called. Stop will shutdown all connection pools.</p> <pre><code>@Inject\nPersistService orientService\n\npublic void onAppStartup(){\n    orientService.start()\n}\n\npublic void onAppShutdown(){\n    orientService.stop()\n}\n</code></pre>"},{"location":"guide/connections/","title":"Connections","text":"<p>Document (actually multi-model)  is the core connection type.  Object and graph  apis use document connection internally. Connection object mainly defines the result of queries: </p> <ul> <li>document connection will always return ODocument</li> <li>object connection returns mapped pojos (actually proxies) or ODocument for fields selections and</li> <li>graph api returns Vertex and Edge types.</li> </ul> <p>And of course connections provide specific apis for types.</p> <p>You can use any connections within single transaction and changes made in one connection type will be visible in other connections. This allows you, for example to update data using object api and create relations using graph api.</p> <p>To access connection object inside transaction use <code>PersistentContext</code> generified with the type of required connection.</p> <ul> <li><code>PersistentContext&lt;ODatabaseObject&gt;</code> for object database connection</li> <li><code>PersistentContext&lt;ODatabaseDocument&gt;</code> for document database connection</li> <li><code>PersistentContext&lt;OrientBaseGraph&gt;</code> for graph database connection (transactional or not)</li> <li><code>PersistentContext&lt;OrientGraph&gt;</code> for transactional graph database connection (will fail if notx transaction type)</li> <li><code>PersistentContext&lt;OrientGraphNoTx&gt;</code> for non transactional graph database connection (will provide only for notx transaction type, otherwise fail)</li> </ul> <p>Note</p> <p>You can't use both OrientGraph and OrientGraphNoTx in the same transaction (type must be used according to transaction type). OrientBaseGraph may be used in places where both types are possible (its the base class for both).</p> <p>Note</p> <p><code>PersistentContext</code> methods are shortcuts for low level api (simplifies usage). You can extend it to add more shortcut methods or make your own: it is not used internally and exists only for public usage.</p> <p>For example</p> <pre><code>public class MyService {\n\n    @Inject    \n    private PersistenceContext&lt;ODatabaseObject&gt; context;\n\n    public List&lt;Model&gt; findByName(final String name) {\n        // manual transaction declaration\n        return context.doInTransaction((db) -&gt; \n            // pure orient api\n            db.query(new OSQLSynchQuery&lt;Model&gt;(\"select from Model where name=?\"), name)\n        );\n    }\n}\n</code></pre> <p>Alternatively, you can directly inject connections:</p> <pre><code>@Inject\nprivate Provider&lt;ODatabaseObject&gt; db;\n</code></pre> <p>But note that it would not work without external transaction.</p>"},{"location":"guide/connections/#manual-connections","title":"Manual connections","text":"<p>In special cases you can inject internal <code>OrientDB</code> object,  used for connections management directly:</p> <pre><code>@Inject Provider&lt;OrientDB&gt; orient;\n</code></pre> <p>With it, you can create or drop databases and create manual connections, not managed with guice.</p> <p>Note</p> <p>Database credentials are accessible (if required) with injectable <code>OrientDBFactory</code> bean.</p>"},{"location":"guide/connections/#pools","title":"Pools","text":"<p>Each connection type is managed with its own <code>PoolManager</code>.</p> <p>Default pool implementations:</p> <ul> <li><code>DocumentPool</code></li> <li><code>ObjectPool</code></li> <li><code>GraphPool</code></li> </ul> <p>Pools are registered in <code>OrientModule</code>'s <code>configurePools()</code> method. You can override it to register your own pool implementations.</p> <p>Custom pools registration example:</p> <pre><code>public class MyOrientModule extends OrientModule {\n\n    @Override\n    protected void configurePools() {\n        bindPool(ODatabaseDocument.class, DocumentPool.class);\n        bindPool(ODatabaseObject.class, ObjectPool.class);\n        bindPool(OrientGraph.class, MyCustomGraphPool.class);\n        // note that for graph few entities could be provided: OrientGraph, OrientGraphNoTx, OrientBaseGraph.\n        // default implementation registers additional providers to handle all cases\n        // see ru.vyarus.guice.persist.orient.support.pool.GraphPoolBinder\n    }\n}\n</code></pre> <p>Default pool implementation maintains only pool for documents (using <code>ODatabasePool</code>). Other pools use document connection to construct object and graph connection objects. This merges different connections transactions (change in one connection type will be visible in all others).</p> <p>Important</p> <p>Connection may be acquired from pool only inside unit of work. Connection object is bound to thread local inside pool, returning always the same instance during transaction.</p> <p>Actual orient transaction is started only when connection object is obtained from pool.</p>"},{"location":"guide/connections/#pools-interactions","title":"Pools interactions","text":"<p>Before v3, each pool manage its own connection, as a result transactions were different for all connection types and changes were not visible between them. </p> <p>Such behavior is still possible: write new pool implementations and register them in OrientModule.</p> <p><code>TransactionManager</code> supports multiple transactions out of the box (legacy behavior). </p> <p>Note</p> <p><code>PoolManager</code>'s commit or rollback methods will be called on each transaction end, even if no connection where obtained from this pool. Pool must control such situation.</p> <p>When explicit rollback called, transaction manager will call rollback on each pool.</p> <p>When exception occurred on commit, other pools will be still committed and rollback called only on failed pool. But other pools will receive rollback call after commit and must ignore it.</p> <p>If you really want to use multi-transactional approach look sources for 2.x brach.</p>"},{"location":"guide/transactions/","title":"Transactions","text":""},{"location":"guide/transactions/#unit-of-work-transaction","title":"Unit of work (transaction)","text":"<p>Unit of work defines transaction scope. Actual orient transaction will start only on first connection acquire (so basically, unit of work may not contain actual orient transaction, but for simplicity both may be considered equal).</p> <p>Unit of work may be defined by:</p> <ul> <li><code>@Transactional</code> annotation on guice bean or single method (additional <code>@TxType</code> annotation allows to define different transaction type for specific unit of work)</li> <li>Inject <code>PersistentContext</code> bean into your service and use its methods</li> <li>Using <code>TransactionManager</code> begin() and end() methods.</li> </ul> <p>First two options are better, because they automatically manage rollbacks and avoid not closed (forgot to call end) transactions.</p> <p>Important</p> <p>Orient 2 is more strict about transactions: now ODocument could be created only inside transaction and object proxy can't be used outside of transaction.</p> <p>Warning</p> <p>When you get error like   <pre><code>Database instance is not set in current thread. Assure to set it with: ODatabaseRecordThreadLocal.instance().set(db)\n</code></pre> It almost certainly means that you perform transactional operation outside of transaction. Simply enlarge transaction scope.    </p> <p>When you inside transaction, <code>activateOnCurrentThread()</code> is called each time you obtain connection from raw connection provider or PersistentContext and you will always have correctly bound connection.    </p> <p>For example, even document creation (<code>new ODocument()</code>) must be performed inside transaction.</p>"},{"location":"guide/transactions/#examples","title":"Examples","text":"<p>Defining transaction for all methods in bean (both method1 and method2 will be executed in transaction):</p> <pre><code>@Transactional\npublic class MyBean {\n    public void method1() ...\n    public void method2() ...\n}\n</code></pre> <p>Defining no tx transaction on method:</p> <pre><code>@Transactional\n@TxType(OTransaction.TXTYPE.NOTX)\npublic void method()\n</code></pre> <p>Notx usually used for scheme updates, but in some cases may be used to speed up execution (but in most cases its better to use transaction for consistency).</p> <p>Using <code>PersistentContext</code>:</p> <pre><code>@Inject PersistentContext&lt;OObjectDatabaseTx&gt; context;\n\n...\ncontext.doInTransaction(new TxAction&lt;Void&gt;() {\n        @Override\n        public Void execute() throws Throwable {\n            // something\n            return null;\n        }\n    });\n</code></pre> <p>Using <code>TransactionManager</code>:</p> <pre><code>@Inject TransactionManager manager;\n...\nmanager.begin();\ntry {\n// do something\n    manager.end();\n} catch (Exception ex) {\n    manager.rollback()\n}\n</code></pre> <p>Note</p> <p>In contrast to spring default proxies, in guice when you call bean method inside the same bean, annotation interceptor will still work. So it's possible to define few units of work withing single bean using annotations:</p> <pre><code>public void nonTxMethod(){\n    doTx1();\n    doTx2();\n}\n\n// methods can't be private (should be at least package private)\n@Transactional\nvoid doTx1() {..}\n\n@Transactional\nvoid doTx2() {..}\n</code></pre>"},{"location":"guide/transactions/#external-transaction","title":"External transaction","text":"<p>In some rear cases it is required to use already created database object (use thread-bound connection inside guice). This is possible by using special <code>TxConfig.external()</code> config.</p> <pre><code>// transaction opened manually\nODatabaseDocumentTx db = new ODatabaseDocumentTx();\n// database object must be bound on current thread (orient did this automatically \n// in most cases, so direct call is not required)\ndb.activateOnCurrentThread();\n\n// context is PersistentContext, but TxTemplate may be called directly\ncontext.doInTransaction(TxConfig.external(), () -&gt; {\n    // here we can use external transaction          \n})\n\n// connection closed manually\ndb.close();\n</code></pre> <p>Important</p> <p>In contrast to normal transaction, guice will not manage commits and rollbacks: it is assumed that connection lifecycle is correctly managed manually.</p> <p>There are intentionally no shortcuts for starting external unit of work because its not supposed to be used often and must be applied only in cases where other behaviour is impossible.</p>"},{"location":"guide/transactions/#retry","title":"Retry","text":"<p>Due to orient implementation specifics, you may face OConcurrentModificationException.</p> <p>Such exception would be ok for optimistic locking check on object save (object contains version and if db version is different then your object considered stale, and you cant save it).</p> <p>But, for example, even query like this may fail:</p> <pre><code>update Model set name = 'updated'\n</code></pre> <p>In concurrent environment this query also may cause <code>OConcurrentModificationException</code>  (other transaction changed object version in between of model update: action must be repeated).</p> <p>There is a special base class for such exceptions: <code>ONeedRetryException</code>. So by design some operations may fail initially, but succeed on repeated execution.</p> <p>To fix such places you can use <code>@Retry</code> annotation. It catches exception and if its <code>ONeedRetryException</code> (or any cause is retry exception) it will repeat method execution.</p> <pre><code>@Retry(100)\n@Transactional\npublic void update()\n</code></pre> <p>Important</p> <p>Annotation must be defined outside of transaction, because retry exception is casted on commit and it's impossible to catch it inside transaction. If <code>@Retry</code> annotated method will be executed under transaction, it will fail (catches redundant definition). So be careful using it: be sure not to use annotated methods in transaction.</p> <p><code>@Retry</code> may be used with <code>@Transactional</code> on the same method (retry applied before).</p> <p>In some cases using script instead of query solves concurrent update problem (even without retry):</p> <pre><code>begin\nupdate Model set name='updated'\ncommit\n</code></pre> <p>Anyway, always write concurrent tests to be sure.</p>"},{"location":"mapping/objectscheme/","title":"Object scheme mapping","text":"<p>Default orient mapping is limited in some cases, and that's why custom mapper implementation provided (extending default mapper).</p> <p>Note</p> <p>This is development time solution to quickly update scheme. Its usage in production is obviously limited.</p>"},{"location":"mapping/objectscheme/#default-object-scheme-mapping","title":"Default object scheme mapping","text":"<p>See orient object mapping documentation for object mapping  (and general object database page).</p> <ul> <li>Orient ignore package, so class may be moved between packages</li> <li>If model class extends some other class it will be also registered as separate scheme class.</li> <li>When entity field removed, orient will hold all data already stored in records of that field</li> <li>When entity field type changes, orient WILL NOT migrate automatically (you need to handle it manually, using custom scheme initializer or through orient studio).</li> <li>When class renamed orient will register it as new entity and you will have to manually migrate all data (it's possible to use sql commands to rename entity in scheme)</li> <li>To use entity within optimistic transaction, it must have version field (annotated with <code>@Version</code>). You should add field manually or extend all entities from provided base class: <code>VersionedEntity</code></li> <li>JPA annotations can be used to define cascades</li> <li>JPA <code>@Id</code> annotation may be used to bind object id (String or Object to bind as RID)</li> </ul> <p>Most useful are id and version mapping:</p> <pre><code>@Id\nprivate String id;\n@Version\nprivate Long version;\n</code></pre> <p>Version property is required for optimistic transactions (enabled by default).</p>"},{"location":"mapping/objectscheme/#graph-types","title":"Graph types","text":"<p>Graph types are usual types with just one difference: its root class must extend <code>V</code> or <code>E</code> (for vertex or edge). You may register scheme class (even with default orient mapper) and later make it as <code>extends V</code> and it will be valid vertex type, usable for graph api.  Extended mapper support this case with <code>@EdgeType</code> and <code>@VertexType</code> annotations.</p>"},{"location":"mapping/objectscheme/#setup","title":"Setup","text":"<p>Mapper is registered as scheme initializer bean, but mapper may be used directly too: <code>ObjectSchemeInitializer</code>.</p> <p>Two scheme initializer implementations provided:</p> <ul> <li><code>PackageSchemeInitializer</code> - use all classes in package to init or update scheme (package should be specified as module constructor argument).</li> <li><code>AutoScanSchemeInitializer</code> - search classpath for entities annotated with <code>@Persistent</code> annotation and use them to create/update scheme.</li> </ul> <p>They can be enabled by <code>PackageSchemeModule</code> and <code>AutoScanSchemeModule</code> modules. </p> <p>Note</p> <p>Modules must be registered together with main <code>OrientModule</code>.</p> <p>For example:</p> <pre><code>install(new AutoScanSchemeModule(\"my.model.root.package\"));\n</code></pre>"},{"location":"mapping/objectscheme/#mapping-annotations","title":"Mapping annotations","text":"<p>Extended mapper provides additional annotations:</p> <p>Class:</p> <ul> <li>@EdgeType - register class as edge type</li> <li>@VertexType - register class as vertex type</li> <li>@RenameFrom - renames existing scheme class before class registration</li> <li>@Recreate - drop and create fresh scheme on each start</li> <li>@CompositeIndex - creates composite index for class (index span multiple properties)</li> <li>@CompositeLuceneIndex - creates composite lucene index for class (index span multiple properties)</li> <li>@DropIndexes - drops existing indexes on start</li> </ul> <p>Field:</p> <ul> <li>@RenamePropertyFrom - renames existing scheme property before class registration</li> <li>@Index - creates index for annotated field</li> <li>@FulltextIndex - creates fulltext index for annotated field</li> <li>@LuceneIndex - creates lucene index for annotated field</li> <li>@Readonly - marks property as readonly</li> <li>@ONotNull - marks property as not null</li> <li>@Mandatory - marks property as mandatory</li> <li>@CaseInsensitive - marks property as case insensitive</li> </ul> <p>Tip</p> <p>New annotations could be implemented easily as plugins.</p> <p>All annotations are safe: they may remain in model even after performing required action (they will just do nothing).  This makes possible to use them as simple migration mechanism (but its better to use something stronger for production).</p> <p>Important</p> <p>Remember that scheme created from objects maintain same hierarchy as your objects. E.g. if you use provided <code>VersionedEntity</code> class as base class for entities, it will be also registered in scheme (nothing bad, you may not notice it). But for graphs hierarchies its more important: both vertex and edge objects can't extend same class (root class in hierarchy must extend V or E). So if you use <code>@VertexType</code> or <code>@EdgeType</code> annotations make sure their hierarchy not intersect.</p> <p>See documentation:</p> <ul> <li>Classes</li> <li>Properties</li> <li>Indexes (create index)</li> </ul>"},{"location":"mapping/objectscheme/#how-it-works","title":"How it works","text":"<p>Suppose we have model: </p> <pre><code>class Model extends BaseModel\n</code></pre> <p>When model class is registered (note that this will be performed by scheme module automatically)</p> <pre><code>objectSchemeInitializer.register(Model.class);\n</code></pre> <p>Its hierarchy parsed and first <code>BaseModel</code> class registered and then <code>Model</code> class.</p> <p>During registration initializer lookups all type and field annotations and execute them before and after orient registration.</p> <p>To avoid registration of same base classes many times, registered classes are cached and not processed next time. Usually, scheme initialization is performed on application startup so you should not notice cache presence. But if you need to register class one more time, you may clear cache manually:</p> <pre><code>objectSchemeInitializer.clearModelCache();\n</code></pre> <p>(<code>ObjectSchemeInitializer</code> is registered as guice bean and so available for injection)</p>"},{"location":"mapping/writing/","title":"Writing custom annotations","text":"<p>Two types of extensions supported: type and field (class and property) extensions.</p> <p>Extensions are resolved from annotations: extension annotation must be annotated with one of: </p> <ul> <li><code>@SchemeTypeInit</code> </li> <li><code>@SchemeFieldInit</code> </li> </ul> <p>This annotation contains extension class, which is instantiated by guice.</p> <p>No explicit registration required for extension: it's always resolved from found annotation.</p> <p>Both type and field extension interfaces (<code>TypeExtension</code>, <code>FieldExtension</code>) contains before and after methods. Before called before registering class with orient default mechanism and after - after registration.</p> <p>Extensions are ordered according to <code>@Order</code> annotation on extension class.</p> <p>Consider using singleton scope extensions. If you will choose prototype scope, then single extension instance will be used for both before and after calls. But different instance will be used for different model classes.</p> <p><code>SchemeDescriptor</code> object is passed to all extension methods and contains some basic context info.  Extension may need to modify descriptor state: e.g. if extension drops existing class in before method, it must set <code>descriptor.initialRegistartion = true</code>.</p> <p>All provided annotations are extensions. Use them as examples.</p> <p><code>AbstractObjectInitializer</code> may be used as base class for custom classpath scan model resolution strategy (instead of two provided).</p>"},{"location":"mapping/writing/#example","title":"Example","text":"<p>As an example, let's take exisitng <code>ONotNull</code> annotation:</p> <pre><code>@Target(FIELD)\n@Retention(RUNTIME)\n@SchemeFieldInit(NotNullFieldExtension.class)\npublic @interface ONotNull {\n\n    boolean value() default true;\n}\n</code></pre> <p>Implementation:</p> <pre><code>@Singleton\npublic class NotNullFieldExtension implements FieldExtension&lt;ONotNull&gt; {\n    private final Logger logger = LoggerFactory.getLogger(NotNullFieldExtension.class);\n\n    @Override\n    public void beforeRegistration(final ODatabaseObject db, final SchemeDescriptor descriptor,\n                                   final Field field, final ONotNull annotation) {\n        // not needed\n    }\n\n    @Override\n    public void afterRegistration(final ODatabaseObject db, final SchemeDescriptor descriptor,\n                                  final Field field, final ONotNull annotation) {\n        final String name = field.getName();\n        final boolean notnull = annotation.value();\n        final OProperty property = db.getMetadata().getSchema()\n                .getClass(descriptor.schemeClass).getProperty(name);\n        if (property.isNotNull() != notnull) {\n            property.setNotNull(notnull);\n            logger.debug(\"Set {}.{} property notnull={}\", descriptor.schemeClass, name, notnull);\n        }\n    }\n}\n</code></pre> <p>That's all: no explicit registrations reqired (assuming that object mapper is registered as schema initializer). </p> <p>When we use annotation on bean:</p> <pre><code>public class Model {\n    @ONotNull\n    private String foo;\n}\n</code></pre> <p><code>ObjectSchemeInitializer</code> will ananlyse bean, find <code>ONotNull</code> annotation and detect that it's annotated with <code>SchemeFieldInit</code>. Specified extension class is instantiated with guice and used.</p>"},{"location":"mapping/class/compositeindex/","title":"@CompositeIndex","text":"<p>Scope: class</p> <p>Creates composite index (index span multiple properties).</p> <pre><code>@CompositeIndex(name = \"test\", type = OClass.INDEX_TYPE.NOTUNIQUE, fields = [\"foo\", \"bar\"])\npublic class MyModel {...}\n</code></pre> <p>For multiple indexes creation use wrapper:</p> <pre><code>@CompositeIndex.List({\n   @CompositeIndex(name = \"test\", type = OClass.INDEX_TYPE.NOTUNIQUE, fields = [\"foo\", \"bar\"])\n   @CompositeIndex(name = \"test2\", type = OClass.INDEX_TYPE.DICTIONARY, fields = [\"foo\", \"bar\"])\n})\npublic class MyModel {...}\n</code></pre> <p>Note that index names are global in orient, so define unique names.</p> <p>If index with specified name is registered, and index type is the same nothing will be done. If existing index type is different - it will be recreated with required type.</p> <p>If existing index build with different fields, error will be thrown.</p>"},{"location":"mapping/class/compositeluceneindex/","title":"@CompositeLuceneIndex","text":"<p>Scope: class</p> <p>Creates composite lucene fulltext index (index span multiple properties).</p> <p><code>com.orientechnologies:orientdb-lucene:2.2.33</code> dependency must be installed to use lucene index.</p> <pre><code>@CompositeLuceneIndex(name = \"test\", fields = [\"foo\", \"bar\"], analyzer = EnglishAnalyzer)\npublic class MyModel {...}\n</code></pre> <p>For multiple indexes creation use wrapper: <pre><code>@CompositeIndex.List({\n   @CompositeLuceneIndex(name = \"test\", fields = [\"foo\", \"bar\"])\n   @CompositeLuceneIndex(name = \"test2\", fields = [\"foo\", \"bar\"], analyzer = EnglishAnalyzer)\n})\npublic class MyModel {...}\n</code></pre></p> <p>Note</p> <p>Index names are global in orient, so define unique names.</p> <p>If index with specified name is registered, and index type is the same nothing will be done. If existing index created with different analyzer - it will be recreated with required analyzer.</p> <p>If existing index build with different fields or it's not lucene index, error will be thrown.</p>"},{"location":"mapping/class/dropindexes/","title":"@DropIndexes","text":"<p>Scope: class</p> <p>Drops existing indexes.</p> <pre><code>@DropIndexes({\"test1\", \"test2\"})\npublic class MyModel {...}\n</code></pre> <p>Important</p> <p>Index drop executed before registration and index creation annotations register indexes after class registration, so drop may be used to re-build index.</p>"},{"location":"mapping/class/edge/","title":"@EdgeType","text":"<p>Scope: class</p> <p>Register class as edge type. On scheme level it means root class must extend E</p> <p>So in simple case <code>YourModel extends E</code>, in hierarchy case <code>YourModel extends YourBaseModel extends E</code></p> <p>Defined on model type:</p> <pre><code>@EdgeType\npublic class MyModel {...}\n</code></pre> <p>If class already registered and its root type does not have assigned superclass, it would be changed to edge type, otherwise error thrown.</p> <p>Note</p> <p>Since orient 2.1 multiple inheritance is available and annotation will assign superclass directly for current class. If any class in hierarchy already extends E then nothing will be done. If any class in hierarchy extends V exception will be thrown (class can't be edge and vertex at the same time)</p>"},{"location":"mapping/class/recreate/","title":"@Recreate","text":"<p>Scope: class</p> <p>Drop annotated class scheme definition before class registration (ofc, data also dropped).</p> <pre><code>@Recreate\npublic class MyCoolModel {...}\n</code></pre> <p>May be used for one-time run in development environment to cleanup model scheme.</p>"},{"location":"mapping/class/rename/","title":"@RenameFrom","text":"<p>Scope: class</p> <p>Renames existing scheme class before class registration. This is important when you rename class to preserve all data under new class name.</p> <p>Note</p> <p>Orient ignores package, so changing model package doesn't need rename.</p> <p>Suppose your class was named <code>MyModel</code> and you rename it to <code>MyCoolModel</code>. To properly migrate data:</p> <pre><code>@RenameFrom(\"MyModel\")\npublic class MyCoolModel {...}\n</code></pre> <p>If <code>MyModel</code> doesn't exist in scheme, no action will be performed. If both classes exist in scheme, error will be thrown.</p>"},{"location":"mapping/class/vertex/","title":"@VertexType","text":"<p>Scope: class</p> <p>Register class as vertex type. On scheme level it means root class must extend V</p> <p>So in simple case <code>YourModel extends V</code>, in hierarchy case <code>YourModel extends YourBaseModel extends V</code></p> <p>Defined on model type:</p> <pre><code>@VertexType\npublic class MyModel {...}\n</code></pre> <p>If class already registered and its root type does not have assigned superclass, it would be changed to vertex type, otherwise error thrown.</p> <p>Note</p> <p>since orient 2.1 multiple inheritance is available and annotation will assign superclass directly for current class.  If any class in hierarchy already extends V then nothing will be done. If any class in hierarchy extends E exception will be thrown (class can't be edge and vertex at the same time)</p>"},{"location":"mapping/property/","title":"@Index","text":"<p>Scope: property</p> <p>Creates index for annotated field.</p> <pre><code>public class MyModel {\n   @Index(OClass.INDEX_TYPE.NOTUNIQUE)\n   private String foo;\n}\n</code></pre> <p>If index name not defined it will be created by convention: .. For example above it will be \"MyModel.foo\" <p>For multiple indexes creation use wrapper: <pre><code>public class MyModel {\n   @Index.List({\n            @Index(value = OClass.INDEX_TYPE.NOTUNIQUE, name = \"test1\"),\n            @Index(value = OClass.INDEX_TYPE.FULLTEXT, name = \"test2\")\n    })\n   private String bar;\n}\n</code></pre></p> <p>In this case name is required (only one index may use default name).</p> <p>Note that index names are global in orient, so define unique names.</p> <p>If index with specified name is registered, and index type is the same nothing will be done. If existing index type is different - it will be recreated with required type.</p> <p>If existing index build with different fields, error will be thrown.</p> <p>Use @CaseInsensitive on properties to make index case-insensitive.</p>"},{"location":"mapping/property/caseinsensitive/","title":"@CaseInsensitive","text":"<p>Scope: property</p> <p>Marks property as case insensitive. Case insensitive properties (collate ci)  are matched in case insensitive way:</p> <pre><code>select from MyModel where name = 'Test'\n</code></pre> <p>If property <code>name</code> is case insensitive then record with name <code>test</code> (for example) will be matched.</p> <pre><code>public class MyModel {\n    @CaseInsensitive\n    private String foo;\n}\n</code></pre> <p>May be used to unset ci marker:</p> <pre><code>public class MyModel {\n    @CaseInsensitive(false)\n    private String foo;\n}\n</code></pre> <p>Marking property ci also affects indexes, created on this property - they are also become ci. In orient ci marker for index and property are different, but if property is ci - index become ci and if  index marked as ci then quite possible it will be used when you query by this property - so it may seem that property is ci too.  Always marking property as ci (with annotation) removes confusion and grants more consistent behaviour.</p> <p>So when you need case-insensitive index use both annotations:</p> <pre><code>public class MyModel {\n    @CaseInsensitive\n    @Index(...)\n    private String foo;\n}\n</code></pre>"},{"location":"mapping/property/fulltextindex/","title":"@FulltextIndex","text":"<p>Scope: property</p> <p>Creates fulltext index for annotated field.</p> <pre><code>public class MyModel {\n   @FulltextIndex(\n            indexRadix = false,\n            ignoreChars = \"'\",\n            separatorChars = \"!?\",\n            minWordLength = 5,\n            stopWords = [\"of\", \"the\"])\n   private String foo;\n}\n</code></pre> <p>Note</p> <p>Fulltext index may be created with <code>@Index</code> annotation too, but this one allows to override default parameters.</p> <p>When no annotation parameters specified - default values will be used (default in annotation are the same as orient defaults).</p> <p>If index name not defined it will be created by convention: .. For example above it will be \"MyModel.foo\" <p>If index with specified name is registered, and index type and parameters are the same then nothing will be done. If existing index type is different or parameters are different - it will be recreated with required type or parameters.</p> <p>If existing index build with different fields or type different from FULLTEXT or FULLTEXT_HASH_INDEX, error will be thrown.  </p>"},{"location":"mapping/property/luceneindex/","title":"@LuceneIndex","text":"<p>Scope: property</p> <p>Creates lucene fulltext index for annotated field.</p> <p><code>com.orientechnologies:orientdb-lucene:2.2.33</code> dependency must be installed to use lucene index.</p> <pre><code>public class MyModel {\n    @LuceneIndex(EnglishAnalyzer)\n   private String foo;\n}\n</code></pre> <p>When analyzer is not specified default StandardAnalyzer will be used</p> <p>If index name not defined it will be created by convention: .. For example above it will be \"MyModel.foo\" <p>If index with specified name is registered, and index type is the same then nothing will be done. If existing index type is lucene with different analyzer - it will be recreated with required analyzer.</p> <p>If existing index build with different fields or its not lucene index then error will be thrown.  </p>"},{"location":"mapping/property/mandatory/","title":"@Mandatory","text":"<p>Scope: property</p> <p>Marks property as mandatory (orient scheme marker)</p> <pre><code>public class MyModel {\n    @Mandatory\n    private String foo;\n}\n</code></pre> <p>May be used to unset mandatory marker:</p> <pre><code>public class MyModel {\n    @Mandatory(false)\n    private String foo;\n}\n</code></pre>"},{"location":"mapping/property/notnull/","title":"@ONotNull","text":"<p>Scope: property</p> <p>Marks property as not null (orient scheme marker)</p> <pre><code>public class MyModel {\n    @ONotNull\n    private String foo;\n}\n</code></pre> <p>May be used to unset not null marker:</p> <p><pre><code>public class MyModel {\n    @ONotNull(false)\n    private String foo;\n}\n</code></pre> Annotation prefixed to avoid conflicts with <code>javax.validation.NotNull</code>.</p>"},{"location":"mapping/property/readonly/","title":"@Readonly","text":"<p>Scope: property</p> <p>Marks property as readonly (orient scheme marker)</p> <pre><code>public class MyModel {\n    @Readonly\n    private String foo;\n}\n</code></pre> <p>May be used to unset readonly marker:</p> <pre><code>public class MyModel {\n    @Readonly(false)\n    private String foo;\n}\n</code></pre>"},{"location":"mapping/property/renameproperty/","title":"@RenamePropertyFrom","text":"<p>Scope: property</p> <p>Renames existing scheme property before class registration. If you rename property, orient scheme mapper simply creates new property, so if you have data in db it will not be visible for new property.</p> <pre><code>public class MyModel {\n   @RenamePropertyFrom(\"foo\")\n   private String bar;\n}\n</code></pre> <p>If specified old property does not exist, no action will be performed.</p> <p>If both properties exist error will be thrown.</p>"},{"location":"repository/commandinternals/","title":"Command methods implementation details","text":"<p>Command method extensions applied to all command extensions (<code>@Query</code>, <code>@Function</code>, <code>@Script</code> etc.)</p> <p>Tip</p> <p>Read repository internals first for better understanding</p>"},{"location":"repository/commandinternals/#common-command-features","title":"Common command features","text":"<p>Commands generally support:</p> <ul> <li>Positional parameters</li> <li>Named parameters</li> <li>Command string el variables</li> </ul> <p>Most commands use <code>CommandMethodDescriptor</code> as descriptor, except <code>@Script</code> which use <code>ScriptCommandMethodDescriptor</code> (to store script language). So when you target <code>CommandMethodDescriptor</code> (in generic), extension will be compatible with all command methods.</p> <p>All command extensions use <code>AbstractCommandExtension</code> as base class. It's very easy to add your own custom command annotation using it (look bundled extensions sources).</p> <p>Command extensions have three execution phases:</p> <ul> <li><code>SqlCommandDescriptor</code> composition</li> <li><code>OCommandRequest</code> composition (orient command)</li> <li>And command execution </li> </ul> <p>Amend extension shoudl implement <code>CommandExtension</code> insterface (to affect execution).</p>"},{"location":"repository/commandinternals/#sqlcommanddescriptor-phase","title":"SqlCommandDescriptor phase","text":"<p><code>SqlCommandDescriptor</code> contains query, prepared parameters (composed from method arguments) and el variables (also composed fro arguments). Extensions could modify query (for example, @Skip appends \"SKIP\" part to query string. Extensions could add (or modify) query parameters. And extensions could add/modify el variables.</p> <p>Positional parameters is a core feature (its parameters without any extension), anyway they could be modified too (for example, <code>@DynamicParams</code> modifies them).</p> <p>Named parameters covered with bundled extension <code>@Param</code>. It is not mandatory to use it: you can write your own extension to define named parameters.</p> <p>El variables defined with <code>@ElVar</code> extension, but again, its not mandatory - you can use your own extension to define variables.</p>"},{"location":"repository/commandinternals/#ocommandrequest-phase","title":"OCommandRequest phase","text":"<p>First of all, el variables replaced in query, producing target query string. Then command object created using prepared query.</p> <p>Extensions could modify resulted command object (for example, <code>@Timaout</code>, <code>@Listen</code>).</p> <p>After all command object wrapped with connection object (using selected RepositoryExecutor) and executed, using composed parameters. Command wrapping is required to bind command to specific connection type. This will affect resulting objects.</p>"},{"location":"repository/commandinternals/#extensions-lifecycle","title":"Extensions lifecycle","text":"<ul> <li>Create <code>SqlCommandDescriptor</code></li> <li>Run extensions to amend descriptor</li> <li>Apply el vars and create <code>OCommandRequest</code></li> <li>Run extensions to amend request object</li> <li>Wrap command with connection and execute with prepared parameters</li> </ul>"},{"location":"repository/commandinternals/#command-parameters-context","title":"Command parameters context","text":"<p>Command extensions use <code>CommandParamsContext</code> during parameters processing.</p> <p>Parameter extensions are called after all parameters processing (to collect all parameters, marked with the same annotation)</p> <p>If you need to modify positional parameters, you can obtain them through <code>paramsContext.getOrdinals()</code>. Usually, there is no need to modify them, because if you need special parameter handling you'll define custom annotation.</p> <p>If your extension defines named parameter you may register it in context: <code>paramsContext.addNamedParam()</code>. After registration, it will be applied automatically.  You may omit registration if your parameter must be converted or something like this (in this case you'll use amend extension to manually apply parameter value).</p> <p>If your extension handles el variable you must declare it either as static <code>paramsContext.addStaticElVarValue()</code> if value is the same for all method executions, or declare it as dynamic <code>paramsContext.addDynamicElVarValue()</code>. In case of dynamic el var, you'll need to use amend extension to manually apply value during execution.</p> <p>Registration of el variables is required, because they are strictly checked and if some not declared variable found in query or declared variable not used in query error will be thrown to indicate method definition error. </p> <p>If you need access to method, type, know root repository type or use generics info, use <code>paramsContext.getDescriptorContext()</code>.  Note that if parameter type is generified, you will receive resolved generic in extension.</p>"},{"location":"repository/commandinternals/#implementing-command-parameter-extension","title":"Implementing command parameter extension","text":"<p>Suppose you want to implement <code>@MyCustomParam</code> parameter extension.</p> <p>Declaring annotation:</p> <pre><code>@Target(PARAMETER)\n@Retention(RUNTIME)\n@MethodParam(MyCustomParamExtension.class)\npublic @interface MyCustomParam { ... }\n</code></pre> <p>If required, define extension options as annotation attributes. <code>@MethodParam</code> marks extension as parameter extension and it will be found and <code>MyCustomParamExtension</code> class obtained from guice context and executed.</p> <p>Now implement extension:</p> <pre><code>@Singleton\npublic class MyCustomParamExtension implements \n        MethodParamExtension&lt;CommandMethodDescriptor, CommandParamsContext, MyCustomParam &gt;{ \n\n    @Override\n    public void processParameters(final CommandMethodDescriptor descriptor, final CommandParamsContext context,\n                                  final List&lt;ParamInfo&lt;MyCustomParam&gt;&gt; paramsInfo) {\n       ...\n    }\n}\n</code></pre> <p>This extension will be called once, during descriptor creation. Here you can validate parameters and, for example, register named parameter or el variable in paramsContext </p> <p>Note</p> <p>We declare <code>MethodParamExtension&lt;CommandMethodDescriptor ...&gt;</code>, this means extension is compatible only with command descriptor and can't be used with delegate (or some other) method extensions. Also, because <code>@Script</code>'s <code>ScriptCommandMethodDescriptor</code> extends CommandMethodDescriptor, this extension is compatible with scripts too.</p> <p>If you need some execution time modification, you'll need to implement amend extension interface:</p> <pre><code>@Singleton\npublic class MyCustomParamExtension implements \n        MethodParamExtension&lt;CommandMethodDescriptor, CommandParamsContext, MyCustomParam&gt;,\n        CommandExtension&lt;CommandMethodDescriptor&gt; { \n\n    public static final String KEY = MyCustomParamExtension .class.getName();\n\n    ...\n    @Override\n    public void amendCommandDescriptor(final SqlCommandDescriptor sql, final CommandMethodDescriptor descriptor,\n                                       final Object instance, final Object... arguments) {\n        ...\n    }\n\n    @Override\n    public void amendCommand(final OCommandRequest query, final CommandMethodDescriptor descriptor,\n                             final Object instance, final Object... arguments) {\n        ...\n    }\n</code></pre> <p>By implementing <code>CommandExtension</code> we did our extension compatible with command methods amend extension. Now parameter extension will be registered as amend extension afeter parameters processing.</p> <p>Most likely you'll need some information from parameters processing method inside executino methods. If it's not a simple value (int, string etc), define your value object <code>MyCustomParamDescriptor</code>. Compose descriptor on processing phase and store inside main method descriptor:</p> <pre><code>descriptor.extDescriptors.put(KEY, yourCustomDescriptor);\n</code></pre> <p>Now in execution method you can obtain it and use:</p> <pre><code>MyCustomParamDescriptor desc = (MyCustomParamDescriptor) descriptor.extDescriptors.get(KEY);\n</code></pre> <p>Note</p> <p>KEY is public. This will allow you to use it in unit tests and possibly, other extensions also could use it (for example, <code>@AsyncQuery</code> must know about <code>@Listen</code> extension).</p> <p>That's all, extension could be used in command method:</p> <pre><code>@Query(\"select from Model\")\nList select(@MyCustomParam String param);\n</code></pre> <p>Look bundled extensions sources for advanced examples.</p>"},{"location":"repository/commandinternals/#implementing-command-method-amend-extension","title":"Implementing command method amend extension","text":"<p>First of all, you can register custom amend extension globally:</p> <pre><code>@Inject AmendExtensionsService amendExtensions;\n...\namendExtensions.addGlobalExtension(new CommandExtension() {...});\n</code></pre> <p>Or you can use custom annotation, for example:</p> <pre><code>@Target({METHOD, TYPE})\n@Retention(RUNTIME)\n@AmendMethod(MyCustomAmendExtension.class)\npublic @interface MyCustomAmend{ ... }\n</code></pre> <p>Amend extensions are searched on method, on type and on root repository type.  You can limit usage scope with <code>@Target</code> annotation (e.g. allow usage only on methods). <code>@AmendMethod</code> marks annotation as amend annotation, now it will be resolved.</p> <p>As with parameters, you eaither implement just parsing interface, to apply extension in descriptor creation time, or implement also amend extension interface, to use extension during method call.</p> <pre><code>@Singleton\npublic class MyCustomAmendExtension implements \n        AmendMethodExtension&lt;CommandMethodDescriptor, MyCustomAmend&gt;,\n        CommandExtension&lt;CommandMethodDescriptor&gt; {\n\n    @Override\n    public void handleAnnotation(final CommandMethodDescriptor descriptor, final MyCustomAmend annotation) {\n        ...\n    }\n\n    ...\n}\n</code></pre> <p>Implementation guideline is the same as with params: use public KEY field and custom descriptor object.</p> <p>Extension could be used like this:</p> <pre><code>@Query(\"select from Model\")\n@MyCustomAmend\nList select();\n</code></pre> <p>See @Timeout as implementation example.</p>"},{"location":"repository/commandmethods/","title":"Command methods","text":"<p>The following methods are using orient commands for execution and called command methods.</p> <ul> <li>@Query  - select/update/insert query</li> <li>@Function - function call</li> <li>@Script - script call (sql, js etc)</li> <li>@AsyncQuery - async query call</li> <li>@LiveQuery - live query subscription</li> </ul>"},{"location":"repository/commandmethods/#common-command-options","title":"Common command options","text":"<p>All command methods annotations has two options:</p> <ul> <li>returnAs - defines required collection implementation</li> <li>connection - defines required connection</li> </ul> <p>Most of the time they are not needed.</p> <p>ReturnAs example:</p> <pre><code>@Query(value = \"select from Model\", returnAs = TreeSet.class)\nSet&lt;Model&gt; select()\n</code></pre> <p>Method will return <code>TreeSet</code> as result (for example, we want sorted results).</p> <p>Connection example:</p> <pre><code>@Query(value = \"select from Model\", connection = DbType.OBJECT)\nList select()\n</code></pre> <p>Result is not generified, so without hint document connection would be selected for method and result will be <code>List&lt;ODocument&gt;</code>. With connection hint actual result will be <code>List&lt;Model&gt;</code>.</p> <p>Another case, when it might be useful is custom converter. For example, you want to convert results to some DTO object, but your converter converts model objects. If you will not use hint:</p> <p><pre><code>@Query(\"select from Model\")\n@ModelDTOConverter\nList&lt;ModelDTO&gt; select()\n</code></pre> This will not work, because document connection will be selected and converter expects objects.  When we set connection hint (<code>connection = DbType.OBJECT</code>), everything will work as planned.</p> <p>Note</p> <p>@ModelDTOConverter does not exist, it's just hypothetical result converter extension you could write, using extension api.</p>"},{"location":"repository/commandmethods/#parameters","title":"Parameters","text":"<p>Commands support positional and named parameters:</p> <pre><code>@Query(\"select from Model where name = ?\")\nList&lt;Model&gt; positional(String name)\n\n@Query(\"select from Model where name = :name\")\nList&lt;Model&gt; named(@Param(\"name\") String name)\n</code></pre> <p>Positional may be used as named too: <pre><code>@Query(\"select from Model where name = :0\")\nList&lt;Model&gt; positional(String name)\n</code></pre></p> <p>For example, script will not work with '?' positional but works which ':0' named-positional.</p>"},{"location":"repository/commandmethods/#el-variables","title":"El variables","text":"<p>All commands support el variables.</p> <p>For example:</p> <pre><code>@Query(\"select from ${type}\")\nList selectAll(@ElVar(\"type\") String type);\n</code></pre> <p>Such variables are inserted into query string before actual execution. In theory may be used even to provide sql parts, but be careful with it.</p> <p>By default you can use generics as el variables:</p> <pre><code>select from ${T}\n</code></pre> <p>where T is generic of query method declaring class (read more about hierarchies below).</p> <p>Another example is oauth providers connection: suppose you have multiple auth providers and user object has property for each provider id. To avoid writing multiple queries for searching user by provider id, we can do like this:</p> <pre><code>@Query(\"select from User where ${provider} = ?\")\nOptional&lt;User&gt; findByProvider(@ElVar(\"provider\") AuthProvider provider, String providerId);\n</code></pre> <p>Where AuthProvider is enum:</p> <pre><code>public enum AuthProvider {\n   google, facebook, twitter\n}\n</code></pre>"},{"location":"repository/commandmethods/#command-methods-parameter-annotations","title":"Command methods parameter annotations","text":"<ul> <li>@Param - named parameter</li> <li>@ElVar - query variable value (substituted in string before query execution)</li> <li>@RidElVar - extract rid from provided object, document, vertex, string orid and insert into query</li> <li>@Var - orient command variable ($var), may be used by query during execution</li> <li>@Skip and @Limit - orient pagination</li> <li>@FetchPlan - defines fetch plan for query</li> <li>@Listen - to provide query listener (required for async queries)</li> <li>@DynamicParams - map dynamic count of parameters from array/collection/map</li> </ul>"},{"location":"repository/commandmethods/#command-amend-annotations","title":"Command amend annotations","text":"<ul> <li>@Timeout - defines query timeout and timeout strategy</li> </ul> <p>Amend annotations may be used directly on method, on class (to apply for all methods) or on root repository type (to apply to all inherited mixins). Command amend methods doesn't affect delegate methods (only if you define command amend annotation directly on delegate method it will cause error, because obviously it's impropriate usage)</p>"},{"location":"repository/commandmethods/#writing-extensions","title":"Writing extensions","text":"<p>You can write custom extensions</p>"},{"location":"repository/delegateinternals/","title":"Delegate method implementation","text":"<p><code>@Delegate</code> method delegates execution to external guice bean method.</p> <p>It's processing is a bit different from command methods: when target method found, parameter extensions processed on target method parameters! Amend extensions are searched on repository method, type and root repository type.</p> <p>Delegate methods use <code>DelegateMethodDescriptor</code>.</p> <p>Delegate execution is:</p> <ul> <li>Prepare arguments array</li> <li>Process extension to fill/modify arguments</li> <li>Call target method</li> </ul> <p>Delegate amend extension interface <code>DelegateExtension</code> allows you to just modify composing arguments array.</p> <p>Parameters context <code>DelegateParamsContext</code> is also simple: supports only ordinal parameters.  But important moment is context: <code>paramsContext.getDescriptorContext()</code> return target method context. It's logical, because param extensions works on target method and so require its context.</p> <p>Repository method context is also accessible with <code>paramsContext.getCallerContext()</code>.</p>"},{"location":"repository/delegateinternals/#implementing-delegate-parameter-extension","title":"Implementing delegate parameter extension","text":"<p>Note</p> <p>Assuming you already read command methods extension guide, some details omitted.</p> <pre><code>@Target(PARAMETER)\n@Retention(RUNTIME)\n@MethodParam(CustomParamExtension.class)\npublic @interface CustomParam { ... }\n</code></pre> <pre><code>@Singleton\npublic class ConnectionParamExtension implements MethodParamExtension&lt;DelegateMethodDescriptor,\n        DelegateParamsContext, CustomParam&gt;, DelegateExtension&lt;DelegateMethodDescriptor&gt; {\n\n    @Override\n    public void processParameters(final DelegateMethodDescriptor descriptor,\n                                  final DelegateParamsContext context,\n                                  final List&lt;ParamInfo&lt;CustomParam&gt;&gt; paramsInfo) {\n        ...\n    }\n\n    @Override\n    public void amendParameters(final DelegateMethodDescriptor descriptor, final Object[] targetArgs,\n                                final Object instance, final Object... arguments) {\n        ...\n    }    \n</code></pre> <p>Note</p> <p><code>DelegateMethodDescriptor</code> used in generic, which limit extension usage for delegates only.</p> <p>Usually, delegate param extension without amend extension interface makes no sense, because values for extended parameters will not be populated by default (these parameters extends repository method signature, so its simply impossible to populate its values automatically). </p> <p>As with command extensions, use KEY field and custom descriptor to pass values between parsing and execution phases.  ParamInfo contains target method parameter position, which you will use to set computed value to arguments array for target method.</p>"},{"location":"repository/delegateinternals/#implementing-delegate-amend-extensions","title":"Implementing delegate amend extensions","text":"<p>As with command, amend extension may be registered globally or defined as annotation on repository method.  All steps are the same as with command, so will omit description.</p> <p>Delegate amend extension could just modify arguments, and I dont know any good usage example for this (that's why no bundled amend annotations provided for delegates: usually, param extensions are more than enough).</p>"},{"location":"repository/delegatemethods/","title":"Delegate methods","text":"<p>Delegate methods delegate execution to other guice bean method. </p> <pre><code>@Delegate(TargetBean.class)\nList&lt;Model&gt; selectSomething();\n</code></pre> <p>On execution, delegating method will be found in <code>TargetBean</code> and executed.  This allows writing custom logic using java api, but still use interface repostory method to call it. So repository interface become single point for all your entity's methods, whereas actual implementation could be decomposed by multiple beans.</p> <p><code>@Delegate</code> may be declared directly on method or on class to apply for all methods. </p> <p>Delegate method implementation may be generic, using some information from calling repository in runtime (generic values, connection object selected for repository method or repository instance itself to use its methods in bean logic).</p> <p>As with other repository methods, delegate bean method execution result will be converted with default (or custom) converter.</p> <p>Delegate annotation support <code>returnAs</code> and <code>connection</code> parameters, the same way as command annotations.</p> <p>Tip</p> <p>When writing mixin, prefer implementing mixin interface in delegate bean. This will make strong reference between them (easier to find). If extension annotations used, and you can't directly implement method, use abstract class (with @ProvidedBy(DynamicSingletonProvider.class)). This way you will keep connection between interface and implementation and be able to use extended method signature.</p> <p>For example, <pre><code>public interface MyMixin {\n\n    @Delegate(OtherBean.class)\n    void something();\n}\n\npublic abstract class OtherBean implements MyMixin {               \n    void something(@Repository Object repo);\n}\n</code></pre> Here delegation target use custom parameters and so can't mark method as <code>@Override</code>,  but overall class implmenets mixin interface, declaring explicit connection between them.</p>"},{"location":"repository/delegatemethods/#method-lookup-algorithm","title":"Method lookup algorithm","text":"<p><code>@Delegate</code> annotation allows you to define</p> <ul> <li>target implementation type with <code>value</code> attribute</li> <li>exact target method name with <code>method</code> attribute (this must be used as last resort, because it introduce weak contract and not refactor-friendly)</li> </ul> <p>Method is searched through all target bean methods (including inherited methods). </p> <p>Algorithm:</p> <ul> <li>If method name set directly (annotation method attribute), look only methods with this name. If method name not set look all public methods.</li> <li>Check all methods for parameter compatibility. Target method must have compatible parameters at the same order(!) Special parameters (extension annotations) may appear at any position (before/after/between).</li> <li>If more than one method found, repository method name used to reduce results (this should be the most useful hint)</li> <li>Method with special parameters (extension annotations) is prioritized. So if few methods found but only one use extensions - it will be chosen.</li> <li>Next, methods are filtered by most specific parameters (e.g. two methods with the same name but one declares String parameter and other Object; first one will be chosen as more specific).</li> <li>If we still have more than one possibility, error will be thrown.</li> </ul>"},{"location":"repository/delegatemethods/#delegate-parameter-annotations","title":"Delegate parameter annotations","text":"<ul> <li>@Generic - generic type value of caller repository (exact class could be specified where to search generic)</li> <li>@Repository - caller repository instance</li> <li>@Connection - db connection object, selected by repository method</li> </ul>"},{"location":"repository/internals/","title":"Repository internals","text":"<p>Repository methods using guice aop and so they could be used in any place. But it's more natural to use them on interface methods.</p> <p>Support for using interfaces and abstract classes in guice is provided by guice-ext-annotations library.  Runtime proxies could be also used (and where used initially) but this way guice aop couldn't be used, which is limitation. Class generation overcomes this limitation making abstract types valid guice beans with aop support.</p> <p>Repositories are build using plugin architecture. Each repository annotation is a plugin and can be replaced if requied.</p>"},{"location":"repository/internals/#how-repositories-work","title":"How repositories work","text":"<p>Repository method executor <code>RepositoryMethodInterceptor</code> is applied using guice aop: to all methods with annotations, annotated with <code>@RepositoryMethod</code>. It is not allowed to use multiple repository method annotations on the same method. If any repository contains such method guice context startup will fail (checked explicitly).</p> <p>During context startup descriptors not computed! This would slow down startup significantly.  Descriptor is always computed on first method call.  So if context start successfully it doesn't mean all repository methods are valid.</p> <p>On repository method call, <code>MethodDescriptorFactory</code> either return cached method descriptor or:</p> <ul> <li>Calls method extension to create descriptor </li> <li>Extension creates descripotor and initialize required fields (possibly set hints in descriptor)</li> <li>Extension calls <code>SpiService.process</code> with <code>ParamsContext</code> instance in order to resolve all extensions</li> <li>Spi service calls <code>ParamsService</code> to process all parameters and param extensions</li> <li>At the end of params processing params service calls <code>ParamsContext.process</code> which analyze all parameters info (and additional information provided by extensions) and creates method specific parameters context and assigns it to method context</li> <li>Next <code>AmendExtensionsService</code> called to resolve all compatible amend extensions.</li> <li>Parameters extensions (holder in ParamsContext) are also checked is they are amend extensions</li> <li>Sorted list of compatible amend extensions (including global) is assigned to descriptor object</li> <li>At the end <code>ResultService</code> called to find converter extensions </li> <li>Result service compose <code>ResultConversionDescriptor</code> and assigns it to method descriptor</li> <li>After descriptor is created by extension</li> <li>Method return type analyzed to compose result descriptor (descriptor.result filed). Affected by returnCollectionHint hint.</li> <li>Using result analysis, executor instance selected and assigned to descriptor (descriptor.executor). Affected by connectionHint.</li> <li>Method extension assigned to descriptor object (as Provider).</li> </ul> <p>Execution:</p> <ul> <li>Extension obtained from descriptor and called to perform execution</li> <li>Extension executes all amend extension from descriptor</li> <li>Extension use executor from descriptor if required (e.g. command extension use it to execute query and delegate use it to obtain connection instance in @Connection extension)</li> <li>Extension returns raw execution result</li> </ul> <p>Result conversion:</p> <ul> <li>Default result converter is called (if not disabled by result extension) to convert result</li> <li>Call result conversion extension if defined</li> <li>Finally result returned</li> </ul>"},{"location":"repository/internals/#repository-extensions","title":"Repository extensions","text":"<p>Repositories support 4 types of extensions:</p> <ul> <li>Method extension - defines repository method logic</li> <li>Repository parameter extension - defines special handling logic for method parameters</li> <li>Amend method extension - extension that influence method behaviour (many parameter extensions are amend extensions also)</li> <li>Result converter extension - extension to extend or modify default result conversion logic </li> </ul>"},{"location":"repository/internals/#method-extension","title":"Method extension","text":"<p>Repository method execution consists of three phases: method descriptor creation, execution and result conversion. Descriptor is created on first call and cached. This is required, because this way first call will be slower, but will be able to perform any heavy computations to validate definition and extensions processing and prepare everything for fast execution on future calls.</p>"},{"location":"repository/internals/#method-descriptor","title":"Method descriptor","text":"<p>Repository descriptor object must extend <code>RepositoryMethodDescriptor</code>. Each method could have unique descriptor or some methods could share the same descriptor type. For example, <code>@Query</code>, <code>@Function</code>, <code>@AsyncQuery</code> use the same descriptor type <code>SqlCommandDescriptor</code> and @Script use uxtended <code>ScriptCommandMethodDescriptor</code>. <code>@Delegate</code> use completely different descriptor object <code>DelegateMethodDescriptor</code>. </p> <p>There are two hint fields in <code>RepositoryMethodDescriptor</code>: returnCollectionHint and connectionHint. Extension may set them to affect return collection type (handled by result converter) and guide executor selection.</p> <p>Descriptor object will be passed to all extension, so it defines which data will be visible to all method specific extensions. Internally root descriptor has <code>extDescriptors</code> map to let extensions store any extension specific data.</p>"},{"location":"repository/internals/#repository-method-extension","title":"Repository method extension","text":"<p>Repository method is defined by annotation, annotated with <code>@RepositoryMethod</code>. Annotation contains actual extension class, which implements <code>RepositoryMethodExtension</code>.</p> <p>Extension is resolved from guice context. Prefer using singletons. Note that extension instance is registered as Provider, so if, for example, prototype scope used, new extension instance will be used for each execution (as a drawback different extension instances will be used for descripotr creation and first execution).</p> <p>Generics are very important!  <code>RepositoryMethodExtension</code> must declare used descriptor object in generic (T). Later this will be used to filter other extensions. Descriptor object also must be generified with supporting amend extensions type (see amend extesnions below). Only extension knows how it would be executed and so only it could define extension interface and properly use it.  For example, command and delegate methods are completely different and so use different extensions interface.</p> <p>Method annotation is searched on methods and on type. You can limit exact extension scope when defining  annotation target. For example, command extensions applies only to method and delegate could be defined on type.</p> <p>Extension must call <code>SpiService.process</code> method to resolve all amend extension, process parameters and extensions and resolve result converter extensions.</p>"},{"location":"repository/internals/#parameters-context","title":"Parameters context","text":"<p>Method extension defines param context object extending <code>ParamsContext</code>. Params context is used by parameter extensions. It's methods define core parameter types. For example, command extensions support positional and named query arguments and also el varables (in query string). Delegate support only target method parameters.</p> <p>Also, params context in responsible for main descriptor update after all parameter extensions processed: it validates all parameters info and updates descriptor for fast processing on execution. Read more about it in parameters extensions section below. </p>"},{"location":"repository/internals/#parameter-extension","title":"Parameter extension","text":"<p>Parameter extensions resolved from parameter annotations. Parameter extension annotation must be annotated with <code>@MethodParam</code>. Annotation defines extension class, which must implement <code>MethodParamExtension</code>. Extension instance is obtained from guice context. Prefer using singleton scope.</p> <p>Again generics are important! During resolution parameter extension checked for compatibility using descriptor type generic. If type defined in extension genric is assignable to current descriptor type - extension is compatible. If some method extensions use descriptors hierarchy, extension may define some middle type in generic to be compatible with all methods. For example, <code>@Script</code> extension use special descriptor which extends <code>CommandMethodDescriptor</code> and all parameter extensions which use <code>CommandMethodDescriptor</code> in generic are compatible with <code>@Script</code> (because declared descriptor type is compatible).</p> <p>All parameters are parsed before calling extension. Extension receive all parameters under extension annotation. This is very handy for validation: for example, some extension requires only one annotated parameter (<code>@Size</code>, <code>@Limit</code> etc).</p> <p>Param extension may use main descriptor's extDescriptors map to store extension specific data, which will be used during execution.</p> <p>Param extension itself is called only on parameters parsing. If extension need to perform some execution time modifications, it must also implement amend extension interface, specific for repository method. In this case parameter extension is registered as amend extension.</p> <p>If parameter extension in universal and could be applied to multiple method types it must not only declare compatible descriptor in generic, but also implement all extension interfaces (if target methods have different extension interfaces).  If parameter extension doesn't implement compatible amend extension interface it simply will not be registered in method amend extensions (the same as if param extension did not implement any amend interface at all).</p> <p>Parameter extension is checked for amend extension compatibility using amend extension type defined in main descriptor generic (RepositoryMethodDescriptor, generic E).</p> <p>Implementation guideline:</p> <ul> <li>Define public static String filed KEY as extension class full name.</li> <li>Define extension specific descriptor object. </li> <li>During parameters processing, validate (if possible), fill specific descriptor and save it in main descriptor: descriptor.extDescriptors.put(KEY, specificDescriptor).</li> <li>For validation use MethodDefinitionException.chec() static method to check and throw exception.</li> <li>In amend extension method you can obtain descriptor descriptor.extDescriptors.get(KEY) and use it.</li> <li>During execution (in amend extension methods) use MethodExecutionException.checkExec static method to check and throw exception.</li> </ul> <p>Only one parameter extension annotation could be defined on single method parameter.</p> <p>Parameters context contains descriptor context object, which may be used to get parsed generics info and root repository class in extension (note that generics object is set to method declaring type by default).</p>"},{"location":"repository/internals/#amend-extensions","title":"Amend extensions","text":"<p>Amend extensions are execution time extensions. They influence method execution by modifying data objects, configuring something etc.</p> <p>Each repository method extension defines its own extension. Such extension interface must extend <code>AmendExecutionExtension</code>.</p> <p>Often amend extensions are registered from parameters extensions. But in some cases, amend extension should be driven by separate annotation. Fro example, @Timeout aextension.</p> <p>Amend extension annotation must be annotated with <code>@AmendMethod</code>, which contains actual extension class. Extension instance is obtained from guice context. Prefer using singleton scope.</p> <p>Amend annotation extension must implement AmendMethodExtension.  Generics are important, because descriptor type is used to check extension compatibility.</p> <p>Amend extension annotations are searched on method, on type and on root repository type. If annotation defined both on method and type, more specific method annotation used and type annotation ignored (the same if annotation defined on repository type and method declaring type - declaring type is more specific).</p> <p>If annotation defined directly on method and it's not compatible (by descriptor) exception will be thrown indicating bad usage.  Incompatible amend annotations found on type or root type are simply ignored. The logic is simple: you may have many methods in repository which must be annotated and only one which is incompatible. You can simpy annotate type to apply annotation for all methods and incompatible method will ignore this annotation.</p> <p>Amend annotation extension may not implement method specific extension interface, in this case it will be executed on repository creation only. In order to affect execution, repository method specific extension interface must be implemented (same as with parameters).</p> <p>If amend extension implements incompatible method specific amend extension interface it will be ignored. So if amend extension is compatible, but execution extension interface is not - extension is executed during descriptor creation, but not registered as execution amend extension.</p> <p>As with parameter extensions, use extension specific descriptor and save it in main method descriptor. Use MethodExecutionException and MethodExecutionException static methods for validation in annotation processing and execution methods.</p> <p>Amend extension are sorted using <code>@Order</code> annotation. </p> <p>All resolved compatible amend extensions are stored in main method descriptor and must be used by method extensions to process extensions (it is impossible to automate, because extensions are method specific and only method knows how and when to process them).</p>"},{"location":"repository/internals/#global-amend-extension","title":"Global amend extension","text":"<p>It is possible to register global amend extensions, which will apply to all executed methods (if compatible). Use <code>AmendExtensionsService.addGlobalExtension(ext)</code>. You can also remove global extension later using <code>removeGlobalExtension</code> method.</p> <p>But remember, that compatible amend extensions are stored in the descriptor, which is computed one time and used for all method executions. So if you register global extension after descriptor creation, it will not affect that method. The same with remove: descriptors created while global extension was registered will still use it. </p> <p>Of course, you can always clear descriptors cache using <code>MethodDescriptorFactory.clearCache()</code>. It will destroy all already pre-computed descriptor and on next call new descriptors will be created.</p> <p>Better approach is to register global extension together with application start (when no repository methods were called).</p>"},{"location":"repository/internals/#result-converter-extensions","title":"Result converter extensions","text":"<p>By default, after every repository method execution result is converted with <code>ResultConverter</code>.  Default implementation do simple conversions between collection types, convertion from list to single element etc. Default implementation may be changed in guice module.</p> <p>If you want to extend or replace default converter behaviour for single method you can use result converter extension.</p> <p>Extension declared using annotation, annotated with <code>@ResultConverter</code>, which contains actual extension class. Extension instance is resolved from guice context. Prefer using singleton scope. Converter us used as Provider so in case of, for example, prototype scope, new instance will be used for each conversion.</p> <p>Pay attention to <code>applyDefaultConverter</code> annotation parameter. It declares if default converter should be applied. This allows you either extend default behaviour or completely replace it. Note that default converter is executed before extension.</p> <p>Extension is searched on method and method declared type. Only one result converter extension is allowed, but if annotation declared on type and method - method annotation will be used.</p> <p>Extension must implement <code>ResultExtension</code> interface. As with other extensions, main descriptor could be used to store extension specific data (e.g. some annotation parameters).</p> <p>You may use <code>RepositoryMethodDescriptor.result</code> descriptor in converter logic. Result descriptor contains method result analysis info (it is used by default converter).</p>"},{"location":"repository/internals/#repository-executor","title":"Repository executor","text":"<p><code>RepositoryExecutor</code> abstracts connection specific calls from repository method processing. Executor is selected by method return type:</p> <ul> <li>If result is <code>ODocument</code> (or generic) then document connection used</li> <li>If result is model class then object connection used</li> <li>If result id <code>Vertex</code> or <code>Edge</code> then graph connection used</li> </ul> <p>Connection object defines type of result types (executing the same query with different connections could return different result objects).</p> <p>User may influence executor selection mechanism by setting required connection type in method annotation. Also, extensions may use descriptor hint to affect executor selection (executor selection performed after descriptor creation and all extensions processing).</p> <p>Default executor implementations may be overridden in <code>RepositoryModule</code>.</p> <pre><code>public class MyRepositoryModule extends RepositoryModule {\n    @Override\n    protected void configureExecutors() {\n          bindExecutor(CustomDocumentFinderExecutor.class);\n          bindExecutor(CustomObjectFinderExecutor.class);\n          bindExecutor(CustomGraphFinderExecutor.class);\n    }      \n}\n</code></pre> <p>As with connections support, executors are registered according to classpath.</p>"},{"location":"repository/mixins/","title":"Repository mixins","text":"<p>Mixins are reusable parts, which you can use in repositories.</p> <p>Interfaces are perfect for writing mixins, because both interface and simple class can implement multiple interfaces and so can use any number of mixins.</p> <p>Java generics plays major role in mixins: as you read before exact method return types are important for proper connection selection. Also, mixins plays parametrization role for commands or for delegates.</p> <p>Generics resolution is implemented as separate lib generics-resolver.</p>"},{"location":"repository/mixins/#command-mixins","title":"Command mixins","text":"<p>All commands support el variables and mixin class generic names may be used as variables:</p> <pre><code>public interface SelectMixin&lt;T&gt; {\n   @Query(\"select from ${T}\")\n   List&lt;T&gt; selectAll();\n}\n</code></pre> <p>Note</p> <p>Neither <code>@Transactional</code> nor <code>@ProvidedBy</code> annotations are not required on mixin, because mixin is not a repository itself, it simply interface.</p> <p>Now when mixin will be used in repository, actual type could be recognized and used:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends SelectMixin&lt;Model&gt; {}\n</code></pre> <p>When method selectAll called from repository, generic resolved and used as variable \"Model\" in query and return type will be treated as <code>List&lt;Model&gt;</code>, allowing correctly select object connection (suppose its registered model type).</p> <p>Depth of hierarchy doesn't matter for generics resolution. So if you want, you can compose few mixins into new one and use it in repositories, instead of implementing all mixins in each repository:</p> <pre><code>public interface RepositoryBaseMixin&lt;T&gt; extends Mixin1&lt;T&gt;, Mixin2&lt;T&gt; {}\n</code></pre>"},{"location":"repository/mixins/#when-object-model-not-used","title":"When object model not used","text":"<p>Suppose you don't want to use object mapping and don't have mapped entities. You may still use generics for types resolution: create empty classes, named the same as your model scheme entities. Use such generics just for queries parametrization.</p> <pre><code>public class ModelName {\n    // empty pojo, used only to specify model name as generic\n}\n\npublic interface MyMixin&lt;T&gt; {\n\n    @Query(\"select from ${T}\")        \n    ODocument query();\n}\n\npublic interface Repository extends MyMixin&lt;ModelName&gt; {    \n}\n</code></pre>"},{"location":"repository/mixins/#extracting-common-logic","title":"Extracting common logic","text":"<p>Imagine you have few different repositories for different entities.  Some of them have <code>name</code> property.</p> <p>Normally you will have to write select by name query in each repository (can't be moved to some base class, because not all entities contains name).</p> <p>You can write generic mixin:</p> <pre><code>public interface NamedEntityMixin&lt;T&gt; {\n\n    @Query(query = \"select from ${T} where name=?\")\n    T findByName(String name);\n}\n</code></pre> <p>Now some repositories could simply implement this interface.  Such things could potentially greatly improve code reuse in repositories.</p>"},{"location":"repository/mixins/#delegate-mixins","title":"Delegate mixins","text":"<p>Delegates provide generalization mechanism for custom logic. Usually, such cases are handled by abstract classes (AbstrctDao or something like this).</p> <p>Comparing to simple bean method call, delegate:</p> <ul> <li>Provides calling repository method context (selected connection, resolved generics etc)</li> <li>Adds support for annotation driven extensions (amend extensions)</li> <li>Applies result conversion</li> </ul> <p>The simplest case is implementing base crud operations for repostiory as delegate mixin:</p> <pre><code>@Delegate(ObjectCrudDelegate.class)\npublic interface ObjectCrud&lt;T&gt; {\n    T get(String id);\n    T create();\n}\n\n@ProvidedBy(DynamicSingletonProvider.class)\npublic abstract class ObjectCrudDelegate&lt;T&gt; implements ObjectCrud&lt;T&gt; {\n    private final Provider&lt;OObjectDatabaseTx&gt; dbProvider;\n\n    @Override\n    public T get(final String id) {\n        return dbProvider.get().load(new ORecordId(id));\n    }\n\n    public T create(@Generic(\"T\") final Class&lt;T&gt; type) {\n        return dbProvider.get().newInstance(type);\n    }\n}\n</code></pre> <p>Now it could be used to easily apply common operation for repository:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectCrud&lt;Model&gt; {}\n</code></pre>"},{"location":"repository/mixins/#bundled-mixins","title":"Bundled mixins","text":"<ul> <li>DocumentCrud - crud operations for document repositories</li> <li>ObjectCrud - crud operations for object repositories</li> <li>ObjectVertexCrud - object crud for using with vertex objects (annotated with @VertexType)</li> <li>EdgesSupport - general support for edge objects (annotated with @EdgeType)</li> <li>EdgeTypeSupport - support for exact edge object type</li> <li>Pagination - pagination support for object or document repositories</li> </ul>"},{"location":"repository/overview/","title":"Repositories","text":"<p>Repository annotations simplify writing dao or repository objects. Repositories are very close to spring-data repositories and following description will follow this approach. But repository methods may be used in any way (like dao or as additional methods for beans).</p> <p>Repositories mainly cover query definitions (removing all boilerplate code). If you need something like spring-data specifications, you can use orientqb</p> <p>Example repository query method:</p> <pre><code>public interface MyRepository {\n\n    @Query(\"select from Model where name=? and nick=?\")\n    List&lt;Model&gt; find(String name, String nick);\n}\n</code></pre> <p>Repositories implementation is based on extensions (every annotation you'll see is an extension). Custom extensions supported, so you can change almost everything.</p>"},{"location":"repository/overview/#setup","title":"Setup","text":"<p>To use repository features register repository module in guice context:</p> <pre><code>install(new RepositoryModule());\n</code></pre>"},{"location":"repository/overview/#guice-abstract-types-support","title":"Guice abstract types support","text":"<p>Repository methods defined with annotations, so interface and abstract methods are ideal candidates to use them. Guice doesn't allow using abstract types, but it's possible with a bit of magic.</p> <p>Abstract types (abstract class or interface containing repository methods) could be registered directly in guice module:</p> <pre><code>bind(MyInterfaceRepository.class).to(DynamicClassGenerator.generate(MyInterfaceRepository.class)).in(Singleton.class)\n</code></pre> <p>Or dynamic resolution could be used (guice JIT resolution):</p> <pre><code>@ProvidedBy(DynamicSingletonProvider.class)\npublic interface MyRepository\n</code></pre> <p>When some bean require this dao as dependency, guice will call provider, which will generate proper class for guice. (dynamic resolution completely replaces classpath scanning: only actually used repositories will be created) Note, this will automatically make bean singleton, which should be desirable in most cases. If you need custom scope use <code>DynamicClassProvider</code> with <code>@ScopeAnnotation</code> annotation (see details in guice-ext-annotations)</p> <p>Note</p> <p>Intellij IDEA will warn you that ProvidedBy annotation is incorrectly typed, but it's ok, because provider is too generic. There is nothing I can do with it and it's the best (the simplest) way I know (without explicit classpath scanning, which is redundant).</p> <p>Important</p> <p>Guice will control instance creation, so guice AOP features will completely work! <code>@Transactional</code> annotation may be used (generally not the best idea to limit transaction to repository method, but in some cases could be suitable). You can think of repository interface or abstract class as of usual guice bean (no limitations).</p> <p>Repository methods are applied using aop (that's why they could be used everywhere).</p>"},{"location":"repository/overview/#repositories-overview","title":"Repositories overview","text":"<p>There 2 types of repository methods:</p> <ul> <li>Commands - orient data manipulation calls (queries, commands, scripts etc) and build around orient command objects</li> <li>Delegates - methods delegate execution to some other beans (useful for generic logic)  </li> </ul> Method annotation Description @Query select/update/insert query @Function orient function call @Script script call (sql, js etc) @AsyncQuery asynchronous query call @LiveQuery orient live query subscription call @Delegate delegate call to other bean method"},{"location":"repository/overview/#defining-repository","title":"Defining repository","text":"<pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository {\n\n    @Query(\"select from Model\")\n    List&lt;Model&gt; selectAll();\n\n    @Query(\"update Model set name = ? where name = ?\")\n    int updateName(String newName, String oldName);\n\n    @Query(\"insert into Model (name) values(:name)\")\n    Model create(@Param(\"name\") String name);\n}\n</code></pre> <p>Note</p> <p>Repository methods could be used to supplement existing bean, but suggest to use pure interface repositories.</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic abstract class MyDao {\n\n    @Query(\"select from Model\")\n    public abstract List&lt;Model&gt; selectAll();\n\n    // normal method\n    public void doSomething() {\n        ...\n    }\n}\n</code></pre> <p>Note</p> <p><code>@Transactional</code> is not required (annotation usage depends on your service architecture, but repository method must be used inside transaction).</p>"},{"location":"repository/overview/#usage-examples","title":"Usage examples","text":"<p>Function call:</p> <pre><code>@Function(\"function1\")\nList&lt;Model&gt; function();\n</code></pre> <p>Positional parameters:</p> <pre><code>@Query(\"select from Model where name=? and nick=?\")\nList&lt;Model&gt; parametersPositional(String name, String nick)\n</code></pre> <p>Named parameters:</p> <pre><code>@Query( \"select from Model where name=:name and nick=:nick\")\nList&lt;Model&gt; parametersNamed(@Param(\"name\") String name, @Param(\"nick\") String nick)\n</code></pre> <p>Pagination:</p> <pre><code>@Query(\"select from Model where name=? and nick=?\")\nList&lt;Model&gt; parametersPaged(String name, String nick, @Skip int skip, @Limit int limit)\n</code></pre> <p>El variable:</p> <pre><code>@Query(\"select from Model where ${prop}=?\")\nList&lt;Model&gt; findBy(@ElVar(\"prop\") String prop, String value)\n</code></pre> <p>Fetch plan parameter:</p> <pre><code>@Query(\"select from Model\")\nList&lt;Model&gt; selectAll(@FetchPlan(\"*:0\") String plan);\n</code></pre> <p>Sql script:</p> <pre><code>@Script(\"begin\" +\n  \"let account = create vertex Account set name = :name\" +\n  \"let city = select from City where name = :city\" +\n  \"let edge = create edge Lives from $account to $city\" +\n  \"commit retry 100\" +\n  \"return $edge\")\nEdge linkCity(@Param(\"name\") String name, @Param(\"city\") String city)\n</code></pre> <p>Js script:</p> <pre><code>@Script(language = \"javascript\", value =\n \"for( i = 0; i &lt; 1000; i++ ){\" +\n     \"db.command('insert into Model(name) values (\\\"test'+i+'\\\")');\" +\n \"}\")\nvoid jsScript()\n</code></pre> <p>Async query:</p> <pre><code>@AsyncQuery(\"select from Model\")\nvoid select(@Listen OCommandResultListener listener)\n</code></pre> <p>Type safe listener (with conversion):</p> <pre><code>@AsyncQuery(\"select from Model\")\nvoid select(@Listen AsyncQueryListener&lt;Model&gt; listener)\n</code></pre> <p>Or with projection:</p> <pre><code>@AsyncQuery(\"select name from Model\")\nvoid select(@Listen AsyncQueryListener&lt;String&gt; listener)\n</code></pre> <p>Dynamic parameters:</p> <pre><code>@Query('select from Model where ${cond}')\nList&lt;ODocument&gt; findWhere(@ElVar(\"cond\") String cond, @DynamicParams Object... params);\n</code></pre> <p>Non blocking (listener execute in different thread):</p> <pre><code>@AsyncQuery(value = \"select from Model\", blocking = false)\nFuture&lt;List&lt;Model&gt;&gt; select(@Listen AsyncQueryListener&lt;Model&gt; listener)\n</code></pre> <p>Delegate example:</p> <pre><code>public class SomeBean {\n   public List getAll() {\n      ...\n   }\n}\n\n@Delegate(SomeBean.class)\nList getAll();\n</code></pre> <p>Live query:</p> <pre><code>@LiveQuery(\"select from Model\")\nint subscribe(@Listen OLiveResultListener listener)\n</code></pre> <p>Type safe listener (with conversion): </p> <pre><code>@LiveQuery(\"select from Model\")\nint subscribe(@Listen QueryResultListener&lt;Model&gt; listener)\n</code></pre> <p>Or vertex conversion:</p> <pre><code>@LiveQuery(\"select from Model\")\nint subscribe(@Listen QueryResultListener&lt;Vertex&gt; listener)\n</code></pre> <p>Unsubscription (usual command call):</p> <pre><code>@Query(\"live unsubscribe ${token}\")\nvoid unsubscribe(@ElVar(\"token\") int token)\n</code></pre> <p>Read more about method usage:</p> <ul> <li>Command methods</li> <li>Delegate methods</li> </ul> <p>Tip</p> <p>For more examples see repository definition examples</p> <p>Writing extensions:</p> <ul> <li>Extending commands</li> <li>Extending delegates</li> </ul>"},{"location":"repository/overview/#return-types","title":"Return types","text":"<p>You can use <code>Iterable</code>, <code>Collection</code>, <code>List</code>, <code>Set</code>, any collection implementation, array, single element or <code>Iterator</code> as return type. Conversion between types will be applied automatically.</p> <pre><code>@Query(\"select from Model\")\nList&lt;Model&gt; selectAll();\n\n@Query(\"select from Model\")\nSet&lt;Model&gt; selectAll();\n\n@Query(\"select from Model\")\nModel[] selectAll();\n\n@Query(\"select from Model\")\nIterable&lt;Model&gt; selectAll();\n\n@Query(\"select from Model\")\nIterator&lt;Model&gt; selectAll();\n</code></pre> <p>If you define single result, when query produce multiple results, first result would be automatically taken:</p> <pre><code>@Query(\"select from Model limit 1\")\nModel selectAll();\n</code></pre> <p>Note</p> <p>Limit is not required, but preferred, as soon as you don't need other results</p>"},{"location":"repository/overview/#projection","title":"Projection","text":"<p>In some cases simple value is preferred, for example:</p> <pre><code>@Query(\"select count(@rid) from Model)\nint count();\n</code></pre> <p>Orient returns <code>ODocument</code> from query with single field (count). Default result converter could recognize when document or vertex contain just one property and return only simple value.</p> <p>Another case is when you select single field:</p> <pre><code>@Query(\"select name from Model\")\nString[] selectNames()\n</code></pre> <p>Read more about projection</p>"},{"location":"repository/overview/#result-type-definition","title":"Result type definition","text":"<p>It is very important to always define exact return type. Connection type defines type of result object: document connection always return <code>ODocument</code>, object return mapped objects (but <code>ODocument</code> for field calls) and graph - <code>Vertex</code> and <code>Edge</code>.</p> <p>Result type is used internally to detect connection type for query.</p> <p>For example, if you write:</p> <pre><code>@Query(\"select from Model\")\nList selectAll();\n</code></pre> <p>You will actually receive <code>List&lt;ODocument&gt;</code>, because without generic it's impossible to detect required return type and document connection used for query.</p> <p>For example, in this case graph connection would be selected:</p> <pre><code>@Query(\"select from Model\")\nList&lt;Vertex&gt; selectAll();\n</code></pre>"},{"location":"repository/overview/#result-conversion","title":"Result conversion","text":"<p>Every repository method result is converted with default converter (as described above).</p> <p>You can use more specific result conversion extension, for example:</p> <pre><code>@Query(\"select from Model\")\n@NoConversion\nList&lt;Model&gt; selectAll();\n</code></pre> <p>NoConversion disables conversion mechanism and you receive result object as is.</p> <p>Read more about converter mechanism and writing custom converters.</p>"},{"location":"repository/overview/#mixins","title":"Mixins","text":"<p>Java support multiple inheritance for interfaces and you can inherit multiple interfaces in classes. So interfaces are ideal for writing small reusable parts (mixins).</p>"},{"location":"repository/overview/#command-mixins","title":"Command mixins","text":"<p>El variables in commands support references to class generics, so you can use it for generic repository logic:</p> <pre><code>public interface MyMixin&lt;T&gt; {\n\n    @Query(\"select from ${T}\")\n    List&lt;T&gt; selectAll()\n}\n\n@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends MyMixin&lt;Model&gt; {}\n</code></pre> <p>When you call mixin method from repository instance</p> <pre><code>repository.selectAll()\n</code></pre> <p>Generic value Model will be used for command <code>select from Model</code> and return type will be resolved as <code>List&lt;Model&gt;</code>, which will allow to select proper connection (object if Model is mapped entity).</p> <p>You may use as many generics as you need. Any repository hierarchy depth will be correctly resolved, so you can even use composition mixins, which wil simply combine commonly used mixins:</p> <pre><code>public interface RepositoryBase&lt;T&gt; extends Mixin1&lt;T&gt;, Mixin2&lt;T&gt; {}\n</code></pre> <p>Note</p> <p>You don't need to set <code>@ProvidedBy</code> annotation on mixins, because it's just interfaces and they are not used as repository instances.</p>"},{"location":"repository/overview/#delegate-mixins","title":"Delegate mixins","text":"<p>Delegates are also support generalization through extensions:</p> <pre><code>public class DelegateBean {\n    public List selectAll(@Generic(\"T\") Class model) {\n\n    }\n}\n\npublic interface MyMixin&lt;T&gt; {\n    @Delegate(DelegateBean.class)\n    List&lt;T&gt; selectAll()\n}\n</code></pre> <p>When delegate bean called from mixin, it will receive generic value (of calling mixin) as parameter.</p> <p>Read more about mixins usage</p>"},{"location":"repository/overview/#bundled-crud-mixins","title":"Bundled crud mixins","text":"<p>Crud mixins are the most common thing: commonly these methods are implemented in <code>AbstractDao</code> or something like this.</p> <p>DocumentCrud mixin provides base crud methods for document repository.</p> <pre><code>public interface MyEntityDao extends DocumentCrud&lt;MyEntity&gt; {}\n</code></pre> <p>Set mixin generic value only if you have reference entity class. Generic affects only <code>getAll</code> and <code>create</code> methods: if generic not set you will not be able to use only this method.</p> <p>ObjectCrud mixin provides base crud methods for object repository:</p> <pre><code>public interface MyEntityRepository extends ObjectCrud&lt;MyEntity&gt; {}\n</code></pre> <p>Now MyEntityRepository has all basic crud methods (create, get, delete etc).</p> <p>Pagination provides simple pagination for your entity or document (but document should have reference type, at least to specify schema type name (may be empty class))</p> <pre><code>public interface MyEntityRepository extends ObjectCrud&lt;MyEntity&gt;, Pagination&lt;MyEntity, MyEntity&gt; {}\n\n...\n// return page\nPage page = repository.getPage(1, 20);\n</code></pre> <p>In order to use pagination mixin, crud mixin is not required (used in example just to mention one more time that mixins could be combined). Pagination mixin is the most complex one and good place to inspire how to write more complex reusable logic.</p> <p>ObjectVertexCrud,  EdgesSupport and EdgeTypeSupport mixins allows using graph features from object api.</p> <pre><code>@vertexType\npublic class Model {}\n\n@EdgeType\npublic class ModelConnection {}\n\n@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectVertexCrud&lt;Model&gt;, \n                       EdgeTypeSupport&lt;ModelConnection, Model, Model&gt; {}\n\n@Inject ModelRepository repository;\n...\nModel from = repository.save(new Model(..));\nModel to = repository.save(new Model(..));\nModelConnection edge = repository.createEdge(from, to);\n</code></pre>"},{"location":"repository/overview/#validation","title":"Validation","text":"<p>You can use guice-validator to apply runtime validation (jsr 303) for repository methods:</p> <pre><code>@Query(\"select from Model where name = ?\")\n@Size(min = 1)\nList&lt;Model&gt; select(@NotNull String name)\n</code></pre> <p>Now this query throw ConstraintViolationException if null provided as parameter or no results returned.</p> <p>Important</p> <p>Register validator module before guice-persist-orient modules! This way validation will be checked before @Transactional or repository methods logic.</p>"},{"location":"repository/result/","title":"Result handling","text":""},{"location":"repository/result/#connection-type-detection","title":"Connection type detection","text":"<p>It is very important to define complete return type, because connection type is detected from method return type.  If you specify generic for returned collection (or iterator) or use typed array (not <code>Object[]</code>) or in case of single element, connection type will be detected like this:</p> <ul> <li>If returned class is registered with object entity manager, object connection will be used</li> <li>If <code>ODocument</code> class returned - document connection used </li> <li>If <code>Vertex</code> or <code>Edge</code> classes returned - graph connection</li> </ul> <p>Connection type directly affects produced objects: the same query will return different result objects, executed with different connections.</p> <p>But, for example, even if you try to select not object itself, but fields you will get <code>ODocument</code>, even in object connection (kind of result set in jdbc). For such case document connection will be selected (according to return type).</p>"},{"location":"repository/result/#return-types","title":"Return types","text":"<p>You can use: <code>Iterable</code>, <code>Collection</code>, <code>List</code>, <code>Set</code>, any collection implementation, array, single element or <code>Iterator</code> as return type. Single elements (single object return) may be wrapped with <code>Optional</code> (guava (<code>com.google.common.base.Optional</code>)  or jdk8 (<code>java.util.Optional</code>)). Collections should not be wrapped with optional, because repository method should never return null for collection or array. </p> <p>Query execution result will be converted in accordance with specified return type.</p> <p>Note</p> <p>Examples below use command methods, but conversion mechanism is applied to all kinds of methods including delegates.</p> <p>For example:  <pre><code>@Query(\"select from Model\")\nModel selectAll()\n</code></pre></p> <p>Returns <code>List&lt;Model&gt;</code>, but converter will take just first element (or null if empty) and return just it.</p> <p>Here first result of returned list is wrapped with optional by converter:</p> <pre><code>@Query(\"select from Model\")\nOptional&lt;Model&gt; selectAll()\n</code></pre> <p>The same for array (returned list will be converted to array):</p> <pre><code>@Query(\"select from Model\")\nModel[] selectAll()\n</code></pre> <p>Sometimes it may be desirable to change default returned collection implementation, e.g. to sort elements:</p> <pre><code>@Query(\"select from Model\", returnAs = TreeSet.class)\nSet&lt;Model&gt; selectAll()\n</code></pre> <p><code>TreeSet</code> collection will be returned. The same result will be if set method return type to <code>TreeSet</code>  (but it's not best practice to define implementation as return type).</p>"},{"location":"repository/result/#result-projection","title":"Result projection","text":"<p>In orient, when you query for some aggregated function (like count) or selecting just one field, <code>ODocument</code> or <code>Vertex</code> objects will be returned (for document/object and graph connections). This is usually not the desired behavior.</p> <p>Projection is unwrapping from document or vertex if it contains just one property. Unwrapping is triggered by return type, e.g.</p> <pre><code>@Query(\"select count(@rid) from Model\")\nint getCount();\n</code></pre> <p>Here return type is int, but actual query will return <code>ODocument</code>. Result converter will detect this, look that document contains just one field (count) and return just this field value.  Note that actual field value could be long or double, conversion to int will also be performed automatically. If return type would be <code>ODocument</code> - no conversion will occur.</p> <p>When we need just one field from multiple rows:</p> <pre><code>@Query(\"select name from Model\")\nString[] getNamesArray();\n</code></pre> <p>Query returns collection of <code>ODocument</code>, but result converter will look return type and unwrap documents returning simple array.</p> <p>Projection detection implemented without possible check overhead and so projection may be used with collections too:</p> <pre><code>@Query(\"select name from Model\")\nList&lt;String&gt; getNamesArray();\n</code></pre> <p>For graph connection this will also work:</p> <pre><code>@Query(value = \"select name from Model\", connection=DbType.GRAPH)\nString[] getNamesArray();\n</code></pre> <p>This time orient will return <code>Vertex</code> instances and result converter will look if vertex contains just one property and unwrap single value.</p> <p>Special case: by default, result converter took first collection element if single result required. So projection may be used like this:</p> <pre><code>@Query(\"select name from Model\")\nString getNamesArray();\n</code></pre> <p>Here collection reduced to one element and single element projected to string value.</p>"},{"location":"repository/result/#default-converter-override","title":"Default converter override","text":"<p>Default converter logic may be overridden in guice module, by simply registering new implementation:</p> <pre><code>bind(ResultConverter.class).to(CustomResultConverter.class)\n</code></pre>"},{"location":"repository/result/#result-extensions","title":"Result extensions","text":"<p>Out of the box two extensions provided:</p> <ul> <li>@NoConversion - disables any conversion</li> <li>@DetachResult - detaches objects (in object connection proxies will be returned, which will not work outside of transaction).</li> </ul>"},{"location":"repository/command/asyncquery/","title":"@AsyncQuery","text":"<p>Command method extension</p> <p>Executes query asynchronously.  By default, async query execution is blocking: method is blocking while listener is called (and listener is executed at the same thread). Such query is useful for dynamic filtering: results are analyzed one by one and you can manually stop further results processing.</p> <p>Example: </p> <pre><code>@AsyncQuery(\"select from Model\")\nvoid select(@Listen OCommandResultListener listener)\n</code></pre> <p>Returned result will be passed to the provided listener (always as <code>ODocument</code>).</p>"},{"location":"repository/command/asyncquery/#listener","title":"Listener","text":"<p>Special listener type could be used to automatically convert the provided document (the same way as repository return result is converted):</p> <pre><code>@AsyncQuery(\"select from Model\")\nvoid select(@Listen AsyncQueryListener&lt;Model&gt; listener)\n</code></pre> <p>Projection will also work:</p> <pre><code>@AsyncQuery(\"select name from Model\")\nvoid selectProjection(@Listen AsyncQueryListener&lt;String&gt; listener)\n</code></pre> <p>And even conversion to graph api:</p> <pre><code>@AsyncQuery(\"select from VertexModel\")\nvoid selectVertex(@Listen AsyncQueryListener&lt;Vertex&gt; listener)\n</code></pre>"},{"location":"repository/command/asyncquery/#non-blocking","title":"Non blocking","text":"<p>Non blocking async query is executed truly asynchronously: listener called in a separate thread. Non blocking query may return future.</p> <pre><code>@AsyncQuery(value = \"select from Model\", blocking = false)\nFuture&lt;List&lt;Model&gt;&gt; selectNonBlock(@Listen AsyncQueryListener&lt;Model&gt; listener)\n</code></pre> <p>Future may be used to wait for the result:</p> <pre><code>// most likely get will be called somewhere later in code and not directly after async method call\nList&lt;Model&gt; result = selectNonBlock().get()\n</code></pre> <p>Listener execution is wrapped with external transacton, so guice can use the same connection instance as orient in current thread. But it is highly recommended to avoid database operations inside listener because listener must execute as fast as possible (orient recommendation).</p> <p>Internally <code>OSQLAsynchQuery</code> or <code>OSQLNonBlockingQuery</code> used accordingly.</p>"},{"location":"repository/command/function/","title":"@Function","text":"<p>Command method extension</p> <p>Function methods execute function.</p> <p>For example, suppose we create a function like this:</p> <pre><code>CREATE FUNCTION function1 \"select from Model\" LANGUAGE SQL\n</code></pre> <p>Now we can call it like this:</p> <pre><code>@Function(\"function1\")\nList&lt;Model&gt; select(String name)\n</code></pre> <p>Internally <code>OCommandFunction</code> used.</p>"},{"location":"repository/command/livequery/","title":"@LiveQuery","text":"<p>Command method extension</p> <p>Subscribe listener to orient live query.</p> <p>Live query may use row orient listener interface:</p> <pre><code>@LiveQuery(\"select from Model\")\nint subscribe(@Listen OLiveResultListener listener)\n</code></pre> <p>Note</p> <p>Live query must start with \"live\", but this is optional as annotation already declares query as live. Anyway, you can write \"live select from Model\" if you want.</p> <p>Subscription call will return subscription token, which may be used to unsubscribe query:</p> <pre><code>@Query(\"live unsubscribe ${token}\")\nvoid unsubscribe(@ElVar(\"token\") int token)\n</code></pre> <p>Special live result listener may be used with automatic conversions support (much like repository method result conversions):</p> <pre><code>@LiveQuery(\"select from Model\")\nint subscribe(@Listen LiveQueryListener&lt;Model&gt; listener)\n</code></pre> <p>Graph api could also be used:</p> <pre><code>@LiveQuery(\"select from VertexModel\")\nint subscribeVertex(@Listen LiveQueryListener&lt;Vertex&gt; listener)\n</code></pre> <p>Of course, pure document is allowed too. But note, that projections will not work here as live query always return entity.</p> <p>Important</p> <p>Listener execution is wrapped with external transaction, so guice can use the same connection instance as orient in current thread.</p> <p><code>OLiveQuery</code> used for query execution.</p>"},{"location":"repository/command/query/","title":"@Query","text":"<p>Command method extension</p> <p>Query methods used for queries (select/update/insert).</p> <p>Select query:</p> <pre><code>@Query(\"select from Model where name=?\")\nList&lt;Model&gt; select(String name)\n</code></pre> <p>Update query:</p> <p><pre><code>@Query(\"update Model set name = ? where name = ?\")\nint update(String to, String from)\n</code></pre> Update query return type could be <code>void</code>, <code>int</code>, <code>long</code>, <code>Integer</code> and <code>Long</code>.</p> <p>Insert query:</p> <p><pre><code>@Query(\"insert into Model (name) values (?)\")\nModel insert(String name)\n</code></pre> Internally <code>OSQLSynchQuery</code> used for selects and <code>OCommandSQL</code> for updates and inserts.</p> <p>Documentation links:</p> <ul> <li>SQL</li> <li>functions</li> <li>methods</li> <li>document api</li> <li>attributes</li> <li>default variables</li> <li>traverse</li> <li>query indexes</li> </ul>"},{"location":"repository/command/script/","title":"@Script","text":"<p>Command method extension</p> <p>Allows you to write small scripts in sql, javascript or any other scripting language.</p> <p>For example:</p> <pre><code>@Script(\"begin\" +\n  \"let account = create vertex Account set name = :name\" +\n  \"let city = select from City where name = :city\" +\n  \"let edge = create edge Lives from $account to $city\" +\n  \"commit retry 100\" +\n  \"return $edge\")\nEdge linkCity(@Param(\"name\") String name, @Param(\"city\") String city)\n</code></pre> <p>By default SQL language used for commands.</p> <p>Example of javascript command:</p> <pre><code>@Script(language = \"javascript\", value =\n \"for( i = 0; i &lt; 1000; i++ ){\" +\n     \"db.command('insert into Model(name) values (\\\"test'+i+'\\\")');\" +\n \"}\")\nvoid jsScript()\n</code></pre> <p>Note that in some cases script allows you to avoid <code>OConcurrentModificationException</code>:</p> <pre><code>@Script(\"begin\" +\n  \"update Model set name = :0\" +\n  \"commit\")\nvoid update(String name)\n</code></pre> <p>This may be not the best way in all cases, but it works (due to implementation specifics simple query may fail in concurrent cases). Also, note as positional parameter used as named. Script doesn't work with positional parameters, but it works like this.</p> <p>Internally <code>OCommandScript</code> used.</p>"},{"location":"repository/command/amend/timeout/","title":"@Timeout","text":"<p>Command method amend extension</p> <p>Sets command execution timeout and timeout strategy (throw exception or return empty result).</p> <pre><code>@Query(\"select from Model\")\n@Timeout(200)\nList&lt;Model&gt; all()\n</code></pre> <p>If query will not execute in 200 milliseconds, exception will be thrown (by default exception timeout startegy used).</p> <pre><code>@Query(\"select from Model\")\n@Timeout(value = 200, strategy = OCommandContext.TIMEOUT_STRATEGY.RETURN)\nList&lt;Model&gt; all()\n</code></pre> <p>Will return empty (or incomplete) result if query executes longer than 200 milliseconds.</p> <p>Internally timeout set using <code>OCommandRequest.setTimeout()</code> method.</p>"},{"location":"repository/command/param/dynamic/","title":"@DynamicParams","text":"<p>Command method param extension</p> <p>Marks parameter as dynamic command parameters provider.</p> <p>For positional parameters, parameter type must be <code>List</code>, array or vararg.</p> <pre><code>@Query(\"select from Model where name=? and nick=?\")\nList&lt;ODocument&gt; positionalList(@DynamicParams List&lt;String&gt; params)\n</code></pre> <p>For named parameters use <code>Map</code>.</p> <pre><code>@Query(\"select from Model where name=:name and nick=:nick\")\nList&lt;ODocument&gt; namedMap(@DynamicParams Map&lt;String, String&gt; params);\n</code></pre> <p>Dynamic parameters may be used with static definitions</p> <pre><code>@Query(\"select from Model where name=? and nick=?\")\nList&lt;ODocument&gt; mixPositional(String name, @DynamicParams String... params);\n</code></pre> <p>Dynamic parameters may be used when it's more comfortable (for any reason) to provide prepared parameters object instead of static parameters binding in method.  And, of course, when number of parameters is not strict.</p> <pre><code>@Query('select from Model where ${cond}')\nList&lt;ODocument&gt; findWhere(@ElVar(\"cond\") String cond, @DynamicParams Object... params);\n</code></pre>"},{"location":"repository/command/param/elvar/","title":"@ElVar","text":"<p>Command method param extension</p> <p>Marks parameter as el variable (variables are substituted in query before execution).</p> <pre><code>@Query(\"select from Model where ${prop} = ?\")\nList&lt;Model&gt; findBy(@ElVar(\"prop\") String prop, String value);\n</code></pre> <p>Any type could be used for variable. Value is converted to string using <code>object.toString</code>. Null value converted to empty string (\"\").</p> <p>If <code>Class</code> used as variable then only class name will be used, for example:</p> <pre><code>@Query(\"select from ${model}\")\nList&lt;Model&gt; findAll(@ElVar(\"model\") Class model);\n</code></pre> <p>It is safe to use <code>Class</code>, <code>Enum</code>, <code>Number</code> (int, long etc), <code>Character</code> types, because they not allow sql injection. But when string or raw object used as value, you can define a list of allowed values to avoid injection:</p> <pre><code>@Query(\"select from Model where ${prop} = ?\")\nList&lt;Model&gt; findAll(@ElVar(value = \"prop\", allowedValues = {\"name\", \"nick\"}) String prop, String value);\n</code></pre> <p>Now if provided value is not \"name\" or \"nick\" exception will be thrown.</p> <p>If you use String variable without list of allowed values, warning will be shown in log (possible injection). If you 100% sure that it's safe, you can disable warning:</p> <pre><code>@Query(\"select from Model where ${cond}\")\nList&lt;Model&gt; findWhen(@ElVar(value = \"cond\", safe = true) String cond);\n...\nrepository.findWhen(\"name='luke' and nick='light'\")\n</code></pre> <p>Also, safe marker documents method safety (kind of \"yes, I'm sure\").</p>"},{"location":"repository/command/param/fetchplan/","title":"@FetchPlan","text":"<p>Command method param extension</p> <p>Annotates parameter as fetch plan value.  This is useful for universal queries to use different fetch plans with different calls.</p> <pre><code>@Query(\"select from Model\")\nList&lt;Model&gt; selectAll(@FetchPlan String plan);\n</code></pre> <p>Only <code>String</code> parameter type may be used.  Default fetch plan may be specified:</p> <pre><code>@Query(\"select from Model\")\nList&lt;Model&gt; selectAll(@FetchPlan(\"*:0\") String plan);\n</code></pre> <p>If null value provided as fetch plan and no default set, then no fetch plan will be set.</p>"},{"location":"repository/command/param/listen/","title":"@Listen","text":"<p>Command method param extension</p> <p>Marks parameter as command listener. Must be used together with @AsyncQuery  or @LiveQuery (exact annotation defines which listener interfaces may be used). </p> <p>Listener will be wrapped with an external transaction, so listener code could access orient connection instance, used for listener from guice (normal connection access).</p>"},{"location":"repository/command/param/pagination/","title":"@Skip and @Limit","text":"<p>Command method param extension</p> <p>Annotates pagination parameters (of course, may be used separately). </p> <pre><code>@Query(\"select from Model\")\nList&lt;Model&gt; getAll(@Skip int skip, @Limit int limit);\n</code></pre> <p>Parameter type may be any <code>Number</code> type (<code>Integer,</code>Long` etc)</p> <p>See bundled Pagination mixin as usage example.</p>"},{"location":"repository/command/param/param/","title":"@Param","text":"<p>Command method param extension</p> <p>Marks named parameter query parameter. Parameter may be of any type, supported by orient. For example, if <code>ODocument</code> passed, orient will use it as <code>@rid</code>. </p> <pre><code>@Query(\"select from Model where name = :name\")\nList&lt;Model&gt; findByName(@Param(\"name\") String name);\n</code></pre> <p>Tip</p> <p>You are not restricted to use only this annotation: you may write your own extension annotation   (e.g. to add some additional validations).</p>"},{"location":"repository/command/param/ridelvar/","title":"@RidElVar","text":"<p>Command method param extension</p> <p>A special el variable to extract rid from provided object, document, vertex, ORID (object or string) and set as el variable.</p> <p>It is implemented as el variable and not as parameter because current orient sql parser works not so well in some cases. For example, query like <code>create edge from ? to ?</code> will not work with parameters (named too) and the only way to make it work is to embed rids directly into query <code>create edge from #12:1 to #12:10</code>.</p> <pre><code>@Query('select from (traverse out from ${id})')\nList&lt;Model&gt; string(@RidElVar(\"id\") String id)\n\n@Query('create edge MyEdge from ${from} to ${to}')\nvoid createEdge(@RidElVar(\"from\") Object from, @RidElVar(\"to\") Object to)\n</code></pre> <p>Note</p> <p>From the first example it looks like <code>@RidElVar</code> could be replaced with simple @ElVar, but it's not: <code>@ElVar</code>  will complain on string parameter because it's not safe for injection. <code>@RidElVar</code> always validate that provided string is valid rid (e.g. #12:11) and fail if string is not (guards from injection).</p> <p>You may use any supported type as variable type: <code>ODocument</code>, object model type, <code>ORID</code>, <code>String</code>, <code>Vertex</code>, <code>Edge</code>.  By using exact type you can restrict method contract. Or use <code>Object</code> to accept all possible values (simplify usage when multiple apis used).</p> <p>Also, may be used for collections, arrays (or varargs). Such types will be inserted as \"[rid1, rid2, rid3]\" into query.</p> <pre><code>@Query(\"select from (traverse out from ${ids})\")\npublic List doSmth(@RidElVar(\"ids\") List&lt;ODocument&gt; ids)\n\n@Query(\"select from (traverse out from ${ids})\")\npublic List doSmth(@RidElVar(\"ids\") Vertex... ids)\n</code></pre> <p>Objects inside collection may be of any supported type (even different objects).</p>"},{"location":"repository/command/param/var/","title":"@Var","text":"<p>Command method param extension</p> <p>Marks parameter as command variable.</p> <p>In contrast to el vars, these variables are used during query execution:</p> <p>For example,</p> <pre><code>@Query('select name from Model where name in $tst')\nString[] findByName(@Var(\"tst\") List tst);\n</code></pre> <p>Note</p> <p>This is not the best example (could be easily rewritten with sql parameter), but it just demonstrates usage.</p>"},{"location":"repository/delegate/delegate/","title":"@Delegate method","text":"<p>Delegate method extension</p> <p>Delegate methods delegate execution to other guice bean method. </p> <pre><code>@Delegate(TargetBean.class)\nList&lt;Model&gt; selectSomething();\n</code></pre>"},{"location":"repository/delegate/param/connection/","title":"@Connection","text":"<p>Delegate method param extension</p> <p>Used to reference connection object, selected for repository method. May be used to avoid writing redundant providers injection and use direct connection from method argument.</p> <pre><code>List doSomething(@Connection OObjectDatabaseTx db) {...}\n</code></pre> <p>Also, may be used for object/document mixins: object and document connections share common abstraction (<code>ODatabaseInternal</code>) which may be used to write generic logic for both connections.</p> <pre><code>List doSomething(@Connection ODatabaseInternal db) {...}\n</code></pre> <p>Even <code>Object</code> may be used as type, to accept any connection type and, for example, branch logic inside method according to connection object type:</p> <pre><code>List doSomething(@Connection Object db) {...}\n</code></pre>"},{"location":"repository/delegate/param/generic/","title":"@Generic","text":"<p>Delegate method param extension</p> <p>Used to reference caller repository method generic.</p> <p>For example, we have mixin definition:</p> <pre><code>public interface SomeMixin&lt;T&gt; {\n   @Delegate(SomeMixinDelegate.class)\n   List&lt;T&gt; findAll()\n}\n\n@ProvidedBy(DynamicSingletonProvider.class)\npublic abstract class SomeMixinDeleagate implements SomeMixin {\n    public List&lt;Model&gt; findAll(@Generic(\"T\") Class model) {\n        ...\n    }\n}\n</code></pre> <p>Now when we use mixin in repository:</p> <pre><code>@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends SomeMixin&lt;Model&gt; {}\n</code></pre> <p>When we call mixin method (<code>findAll</code>) on repository, it will delegate to bean method with <code>Model.class</code> as parameter (resolved generic).</p> <p>By default, generic is resolved from mixin method definition class (<code>SomeMixin</code> in example above). In more complex cases you may need to know generic from some other type (and you sure this type is present in calling repository hierarchy). To do it specify type in annotation:</p> <pre><code>List findAll(@Generic(value = \"T\", genericHolder = SomeOtherMixin.class) Class model) {...}\n</code></pre> <p>See ObjectCrud and DocumentCrud mixins for usage examples.</p>"},{"location":"repository/delegate/param/repository/","title":"@Repository","text":"<p>Delegate method param extension</p> <p>Used to reference calling repository instance.  For example, if you sure that calling repository will contain some mixin (e.g. base mixin used for all repositories) and you need to use its methods.</p> <pre><code>void doSomething(@Repository ObjectCrud repository){...}\n</code></pre> <p>Good example is Pagination mixin (see how <code>PageSupportDelegate</code> reference <code>Pagination</code> mixin, which defines pagination queries and use them to compose page object).</p>"},{"location":"repository/mixin/doccrud/","title":"DocumentCrud","text":"<p>Provide basic crud operations for document connection.  Usage:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends DocumentCrud&lt;Model&gt; {}\n</code></pre> <p>It relies on model class to resolve model type, but, even empty class may be used (just to define scheme class name).</p>"},{"location":"repository/mixin/edges/","title":"EdgesSupport","text":"<p>Provide basic operations for edge objects: objects annotated with @EdgeType  or simply <code>extends E</code> in scheme. This mixin mixes Object and Graph apis to let you correctly work with graph edges through object api.</p> <p>It is very convenient to use edge objects even if they have no properties: it's more type safe and you can use hierarchy of edge types for polymorphic queries.</p> <p>For example, if you have <code>BaseConnection</code> and <code>SpecificConnection extends BaseConnection</code> then querying for <code>BaseConnection</code> type edges will return everything and when required we can query only for <code>SpecificConnection</code> to get more specific results (you can see a lot of examples in orient docs with querying edges by base class <code>E</code>). This works the same way as with normal objects (vertexes) providing very powerful ability for design.</p> <p>Mixin intended to be used as supplement to ObjectVertexCrud (to add edge functions for vertex repository).</p> <p>Note</p> <p><code>EdgesSupport</code> may be used directly (injected as bean). This is because its very generic itself.</p>"},{"location":"repository/mixin/edges/#edges-creation","title":"Edges creation","text":"<p>To create new edge we always need two objects (from and to vertexes). You can use objects, vertexes, documents or simply string id's.</p> <pre><code>@Inject EdgesSupport edges;\n...\nMyEdgeType edge = edges.createEdge(MyEdgeType.class, from, to)\n</code></pre> <p>Here new edge of class <code>MyEdgeType</code> is created between from and to vertexes. Api returns object instance of edge, which may be used for property updates or some other need.</p> <p>If edge contains properties, you can create edge from object or document instance:</p> <pre><code>MyEdgeType edge = edges.createEdge(from, to , new MyEdgeType(...));\n</code></pre> <p>Orient graph api is hiddent, but you can always convert edge object to orient edge and back: use <code>edgeToObject</code> and <code>objectToEdge</code> methods.</p>"},{"location":"repository/mixin/edges/#working-with-edge","title":"Working with edge","text":"<p>In orient, edges are stored as normal objects (they just have special meaning). So you can operate on edge using any api (document, object and graph). But always remove edges with graph api to grant consistency.</p> <p>Edge creation methods return created edge as object (it's an edge record loaded with object api). This is useful for edge properties updates:</p> <pre><code>MyEdgeType edge = edges.createEdge(MyEdgeType.class, form, to);\nedge.setName(\"some name\");\nedges.updateEdge(edge);\n</code></pre> <p>Method updateEdge is generic and accepts not just object pojo but also OrientEdge instance.</p>"},{"location":"repository/mixin/edges/#searching-edge","title":"Searching edge","text":"<p>You can find edge of type by nodes:</p> <pre><code>MyEdgeType edge = edges.findEdge(MyEdgeType.class, from, to)\n</code></pre> <p>Or ignoring direction:</p> <pre><code>MyEdgeType edge = edges.findEdgeBetween(MyEdgeType.class, node1, node2)\n</code></pre> <p>As with creation, object, document, vertex or rid may be used as node parameters.</p> <p>Note</p> <p>Api returns only first edge! There may be other edges. For example, create method is not checking existing edge between nodes, so you can create many edges (even of the same class) between same nodes.</p> <p>You can always make your own methods with sql (or maybe custom delegate logic) to implement more specific search cases.</p>"},{"location":"repository/mixin/edges/#removing-edges","title":"Removing edges","text":"<p>Edge may be removed directly</p> <pre><code>edges.deleteEdge(edge);\n</code></pre> <p>Using object, document, orient edge or rid.</p> <p>Or you can remove all edges of type (possibly more then one!) between nodes (but only in one direction!):</p> <pre><code>int cnt = edges.deleteEdge(MyEdgeType.class, from, to);\n</code></pre>"},{"location":"repository/mixin/edgetype/","title":"EdgeTypeSupport","text":"<p>Very similar to EdgesSupprt mixin, but for one concrete edge type. Also, you can restrict from/to types using generics.</p> <p>It also supposed to be used to supplement ObjectVertexCrud.</p> <pre><code>@VertexType\npublic class Model {}\n\n@EdgeType\npublic class ModelConnection {}\n\n@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectVertexCrud&lt;Model&gt;, \n                       EdgeTypeSupport&lt;ModelConnection, Model, Model&gt; {}\n</code></pre> <p>It uses EdgesSupport as bean internally and may serve as an example of how to implement more specific edge mixins.</p>"},{"location":"repository/mixin/objcrud/","title":"ObjectCrud","text":"<p>Provide basic crud operations for object connection.  Usage:</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectCrud&lt;Model&gt; {}\n</code></pre> <p>You can use <code>objectToDocument</code> and <code>documentToObject</code> methods for conversion to/from documents.</p> <p>Note</p> <p>Don't use it with vertex objects (annotated with @VertexType).  Use ObjectVertexCrud instead.</p>"},{"location":"repository/mixin/objvcrud/","title":"ObjectVertexCrud","text":"<p>Provide basic crud operations for vertex objects: objects annotated with @VertexType or  simply <code>extends V</code> in scheme. This mixin mixes Object and Graph apis to let you correctly work with graph vertexes through object api.</p> <p>It has the same api as ObjectCrud (internally they both extend the same <code>BaseObjectCrud</code> mixin). </p> <p>Warning</p> <p>It is important to use this specific version because it uses graph api for remove: if object api directly used, graph consistency is not checked and so edges leading to/from this vertex are not removed.  </p> <p>It also contains special methods for conversion between object and graph api: <code>vertexToObject</code> and <code>objectToVertex</code>.</p> <pre><code>@VertexType\npublic class Model {}\n\n@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectVertexCrud&lt;Model&gt; {}\n</code></pre> <p>You can use it together with EdgesSupport or EdgeTypeSupport to add relevant edges operations into repository.</p> <p>For example, suppose we want to always connect <code>Model</code> objects with <code>ModelConnection</code> edge type:</p> <pre><code>@EdgeType\npublic class ModelConnection {}\n\n@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface ModelRepository extends ObjectVertexCrud&lt;Model&gt;, \n                       EdgeTypeSupport&lt;ModelConnection, Model, Model&gt; {}\n</code></pre> <p>Now we can operate on objects and connect them with the same repository:</p> <pre><code>@Inject ModelRepository repository;\n...\nModel from = repository.save(new Model(..));\nModel to = repository.save(new Model(..));\nModelConnection edge = repository.createEdge(from, to);\n\n// we may update edge object properties (if it contains it)\nedge.setComment(\"important connection\");\nrepository.updateEdge(edge);\n</code></pre>"},{"location":"repository/mixin/pagination/","title":"Pagination","text":"<p><code>Pagination</code> mixin provides simple pagination for your object entity or document (but document should have reference type, at least to specify schema type name (may be empty class)).</p> <pre><code>@Transactional\n@ProvidedBy(DynamicSingletonProvider.class)\npublic interface MyEntityRepository extends ObjectCrud&lt;MyEntity&gt;, Pagination&lt;MyEntity, MyEntity&gt; {}\n...\n// return page\nPage page = repository.getPage(1, 20);\n</code></pre> <p>Pagination provides 3 methods:</p> <ul> <li><code>getPage</code> - receive composed page object</li> <li><code>getAll</code> - paginated data selection</li> <li><code>getCount</code> - count of all entities</li> </ul>"},{"location":"repository/mixin/pagination/#implementation","title":"Implementation","text":"<p>Pagination implementation is a very good example mixin:</p> <p>Base class <code>PageSupport</code> is delegate (to <code>PageSupportDelegate</code>), which incapsulates Page object logic. <code>Pagination</code> interface extends it (<code>Pagination&lt;M, R&gt; extends PageSupport&lt;R&gt;</code>) and defines query methods (for actual data and entore count).</p> <p>PageSupportDelegate use reference to repository to call these methods:</p> <pre><code>public Page getPage(@Repository final Pagination repository, final int page, final int pageSize)\n</code></pre> <p>Assuming <code>Pagination</code> interface will be always used and so delegate could be sure about repository type (implementing just <code>PageSupport</code> in repository would make no sense).</p>"},{"location":"repository/result/detach/","title":"@DetachResult","text":"<p>Results detaching may be used only with object connection (will be always the case when expected result is model class (or collection of model classes)).</p> <pre><code>@Query(\"select from Model\")\n@DetachResult\nList&lt;Model&gt; selectAll()\n</code></pre> <p>This may be important if you use small transaction scopes, e.g. if method above represent transaction scope, then if we will call it without detach converter, then any attempt to access list object field will fail: returned proxies doesn't work without transaction.</p> <p>Note</p> <p>Used detach method will completely unproxy entire object tree. If for example, you use remote connection with fetch plan, then detach will load entire graph during detaching.</p> <p>In most cases detach should be not needed, because most likely entire business logic will be covered with transaction.</p> <p>You can use this extension as reference for writing your own conversion extension.</p>"},{"location":"repository/result/noconvert/","title":"@NoConversion","text":"<p>Disables any result conversion. </p> <p>Note</p> <p>By default special converter applied globaly handles many cases like collection reducing to single element, projections etc.</p> <p>For example:</p> <pre><code>@Query(\"select from Model\")\n@NoConversion\nModel selectAll()\n</code></pre> <p>This query will fail to execute, because of class cast exception: returned <code>List&lt;Model&gt;</code> can't be casted to <code>Model</code>.</p>"}]}